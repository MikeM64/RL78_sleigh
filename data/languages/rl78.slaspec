#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg and aerosoul94
#
# MikeM64, 2020
#########################################################################

#
# Current TODO list:
#   - Prefix instructions
#   - Rest of the manual...
#

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 wordsize=1 default;
define space stackarea  type=ram_space      size=2;
define space register   type=register_space size=1;

# General Purpose registers
define register offset=0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit-mode bank3
define register offset=0x00 size=2 [AX3   BC3   DE3   HL3  ];  #16-bit-mode bank3
define register offset=0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit-mode bank2
define register offset=0x08 size=2 [AX2   BC2   DE2   HL2  ];  #16-bit-mode bank2
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit-mode bank1
define register offset=0x10 size=2 [AX1   BC1   DE1   HL1  ];  #16-bit-mode bank1
define register offset=0x18 size=1 [X  A  C  B  E  D  L  H ];  # 8-bit-mode bank0
define register offset=0x18 size=2 [AX    BC    DE    HL   ];  #16-bit-mode bank0

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x60 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z RBS1 AC RBS0 ISP1 ISP0 CY];

# Implementation-specific special function registers, starting from 0xFFF00
define ram offset=0xFFF00 size=1 [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

define pcodeop divwu;
define pcodeop machu;
define pcodeop mach;

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    opcode = (0, 7)
    op_h = (4, 7)
    op_l = (0, 3)
    # Whether an rp (16-bit) register is the data source
    rp_source = (0, 0)
    movw_op = (3, 3)
    dreg_word = (1, 2)
    dreg_byte = (0, 2)
    dreg_axbc = (0, 1)
    sreg_byte = (0, 2);
attach variables [ dreg_byte sreg_byte ] [X A C B E D L H];
attach variables [ dreg_axbc ] [X A C B];
attach variables [ dreg_word ] [AX BC DE HL];

define token base2 (8)
    # NOTE: Many arithmetic instructions that act upon registers
    # alone are decoded by the upper 5 bits of the second byte
    # of the opcode. Ex. XOR 0x78 >> 3 -> 0xf
    op2_h       = (3, 7)
    # Bit arithmetic uses the nibble of the second byte
    # to determine the operation (See SHR)
    op2_l       = (0, 3)
    shr_n       = (4, 7)
    sreg2_byte  = (0, 2);
attach variables [ sreg2_byte ] [X A C B E D L H];

define token data8 (8)
    data        = (0, 7)
    uaddr8      = (0, 7)
    sfr_byte    = (0, 7);
attach variables [ sfr_byte ] [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

define token data16 (16)
    dataw = (0, 15)
    uaddr16 = (0, 15);

#########################################################################
#
# Instruction macros
#
#########################################################################

macro inst_xch(dst, src) {
    local tmp:1 = dst;
    dst = src;
    src = tmp;
}

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

macro inst_movs(dst) {
    dst = X;
    Z = (X == 0);
    CY = (X == 0) | (A == 0);
}

macro inst_add(dst, src) {
    dst = dst + src;
    Z = (dst == 0);
    CY = carry(dst, src);
    AC = (dst & 0x04) < (src & 0x04);
}

macro inst_addc(dst, src) {
    dst = dst + CY;
    inst_add(dst, src);
}

macro inst_sub(dst, src) {
    dst = dst - src;
    Z = (dst == 0);
    CY = sborrow(dst, src);
    AC = (dst & 0x08) >= (src & 0x08);
}

macro inst_subc(dst, src) {
    dst = dst - CY;
    inst_sub(dst, src);
}

macro inst_and(dst, src) {
    dst = dst & src;
    Z = (dst == 0);
}

macro inst_or(dst, src) {
    dst = dst | src;
    Z = (dst == 0);
}

macro inst_xor(dst, src) {
    dst = dst ^ src;
    Z = (dst == 0);
}

macro inst_incw(dst) {
    dst = dst + 1;
}

macro inst_decw(dst) {
    dst = dst - 1;
}

macro inst_shr(dst, n) {
    CY = dst:1 & 0x01;
    dst = dst >> n;
}

macro inst_cmp(dst, src) {
    Z = (dst - src) == 0;
    AC = (dst & 0x08) >= (src & 0x08);
    CY = sborrow(dst, src);
}

macro inst_cmp0(dst) {
    Z = dst == 0;
    AC = 0;
    CY = 0;
}

macro inst_cmps(dst, src) {
    Z = (dst - src) == 0;
    CY = (Z != 0) | (A == 0) | (dst == 0);
    AC = (dst & 0x08) >= (src & 0x08);
}

macro inst_addw(dst, src) {
    CY = carry(dst, src);
    dst = dst + src;
    Z = (dst == 0);
    AC = 0;
}

macro inst_subw(dst, src) {
    CY = sborrow(dst, src);
    dst = dst - src;
    Z = (dst == 0);
    AC = 0;
}

macro inst_cmpw(dst, src) {
    Z = (dst - src) == 0;
    AC = 0;
    CY = sborrow(dst, src);
}

macro update_psw(data) {
    # Update PSW as expected
    PSW    = data;
    # Then split it apart into the shadow registers
    # for use during decompilation
    IE     = (data & 0x80) >> 7;
    Z      = (data & 0x40) >> 6;
    RBS1   = (data & 0x20) >> 5;
    AC     = (data & 0x10) >> 4;
    RBS0   = (data & 0x08) >> 3;
    ISP1   = (data & 0x04) >> 2;
    ISP0   = (data & 0x02) >> 1;
    CY     = (data & 0x01);
}

#########################################################################
#
# Root table constructors
#
#########################################################################

# Instruction data tokens

u8: "#"data is data {
    local tmp:1 = data;
    export tmp;
}

u16: "#"dataw is dataw {
    local tmp:2 = dataw;
    export tmp;
}

saddr: loc is uaddr8 [ loc = 0xFFE00 + uaddr8; ] {
    export *:1 loc;
}

saddrp: uaddr8 is uaddr8 {
    local loc:3 = (0xFFFE00 + uaddr8) & 0xFFFFFE;
    export *:2 loc;
}

addr16: "!"loc is uaddr16 [ loc = 0xF0000 + uaddr16; ] {
    export *:1 loc;
}

addr16w: "!"uaddr16 is uaddr16 {
    local tmp:3 = (0xF0000 + uaddr16) & 0xFFFFFE;
    export *:2 tmp;
}

sfrp: loc is sfr_byte [ loc = 0xFFF00 + sfr_byte; ] {
    export *:1 loc;
}

# TODO: Doesn't mask off on even addresses without complicating the
# decompilation. Tried to calculate using the below:
# local tmp:3 = (0xFFF00 + zext(sfr_byte)) & 0xFFFFFE;
sfrpw: sfr_byte is sfr_byte {
    local tmp:3 = zext(sfr_byte);
    export *:2 tmp;
}

# Register Ponter tokens - [r]

AddrDE: [DE] is DE {
    local loc:3 = zext(DE);
    export *:1 loc;
}

AddrDEW: [DE] is DE {
    local loc:3 = zext(DE);
    export *:2 loc;
}

AddrDEOffset: [DE+uaddr8] is DE & uaddr8 {
    local loc:3 = zext(DE) + uaddr8;
    export *:1 loc;
}

AddrDEOffsetW: [DE+uaddr8] is DE & uaddr8 {
    local loc:3 = zext(DE) + uaddr8;
    export *:2 loc;
}

AddrHL: [HL] is HL {
    local loc:3 = zext(HL);
    export *:1 loc;
}

AddrHLW: [HL] is HL {
    local loc:3 = zext(HL);
    export *:2 loc;
}

AddrHLOffset: [HL+uaddr8] is HL & uaddr8 {
    local loc:3 = zext(HL) + uaddr8;
    export *:1 loc;
}

AddrHLOffsetW: [HL+uaddr8] is HL & uaddr8 {
    local loc:3 = zext(HL) + uaddr8;
    export *:2 loc;
}

AddrHLOffsetB: [HL+B] is HL & B {
    local loc:3 = zext(HL) + zext(B);
    export *:1 loc;
}

AddrHLOffsetC: [HL+C] is HL & C {
    local loc:3 = zext(HL) + zext(C);
    export *:1 loc;
}

AddrWordOffsetB: uaddr16[B] is uaddr16 & B {
    local loc:3 = uaddr16 + zext(B);
    export *:1 loc;
}

AddrWordOffsetBW: uaddr16[B] is uaddr16 & B {
    local loc:3 = (uaddr16 + zext(B)) & 0xFFFFFE;
    export *:2 loc;
}

AddrWordOffsetC: uaddr16[C] is uaddr16 & C {
    local loc:3 = uaddr16 + zext(C);
    export *:1 loc;
}

AddrWordOffsetCW: uaddr16[C] is uaddr16 & C {
    local loc:3 = (uaddr16 + zext(C)) & 0xFFFFFE;
    export *:2 loc;
}

AddrWordOffsetBC: uaddr16[BC] is uaddr16 & BC {
    local loc:3 = uaddr16 + zext(BC);
    export *:1 loc;
}

AddrWordOffsetBCW: uaddr16[BC] is uaddr16 & BC {
    local loc:3 = (uaddr16 + zext(BC)) & 0xFFFFFE;
    export *:2 loc;
}

AddrSPOffset: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = zext(SP) + uaddr8;
    export *:1 loc;
}

AddrSPOffsetW: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = zext(SP) + uaddr8;
    export *:2 loc;
}

#########################################################################
#
# Root table instructions
#
#########################################################################

:NOP is opcode=0x00 {}

:HALT is opcode=0x61; opcode=0xED { halt(); }

:STOP is opcode=0x61; opcode=0xFD { stop(); }

#
# Table 1/30
#

# MOV r, #byte
:MOV dreg_byte, "#"data is op_h=0x5 & dreg_byte; data {
    dreg_byte = data;
}

# MOV r, A
:MOV dreg_byte, A is op_h=0x7 & A & dreg_byte {
    dreg_byte = A;
}

# MOV A, r
:MOV A, sreg_byte is op_h=0x6 & A & sreg_byte {
    A = sreg_byte;
}

# MOV saddr, #byte
:MOV saddr, "#"data is opcode=0xCD; saddr; data {
    saddr = data;
}

# MOV sfr, #byte
:MOV sfr_byte, "#"data is opcode=0xCE; sfr_byte; data {
    sfr_byte = data;
}

# MOV !addr16, #byte
:MOV addr16, "#"data is opcode=0xCF; addr16; data {
    addr16 = data;
}

# MOV A, saddr
:MOV A, saddr is opcode=0x8D & A; saddr {
    A = saddr;
}

# MOV saddr, A
:MOV saddr, A is opcode=0x9D & A; saddr {
    saddr = A;
}

# MOV A, sfr
:MOV A, sfrp is opcode=0x8E & A; sfrp {
    A = sfrp;
}

# MOV sfr, A
:MOV sfrp, A is opcode=0x9E & A; sfrp {
    sfrp = A;
}

# MOV A, !addr16
:MOV A, addr16 is opcode=0x8F & A; addr16 {
    A = addr16;
}

# MOV !addr16, A
:MOV addr16, A is opcode=0x9F & A; addr16 {
    addr16 = A;
}

# MOV PSW, #byte
:MOV PSW, "#"data is opcode=0x9F & PSW; opcode=0xFA; data {
    update_psw(data);
}

# MOV A, PSW
:MOV A, PSW is opcode=0x8E & A & PSW; opcode=0xFA {
    A = PSW;
}

# MOV PSW, A
:MOV PSW, A is opcode=0x9E & A & PSW; opcode=0xFA {
    update_psw(A);
}

# MOV ES, #byte
:MOV ES, "#"data is opcode=0x41 & ES; data {
    ES = data;
}

# MOV ES, saddr
:MOV ES, saddr is opcode=0x61 & ES; opcode=0xB8; saddr {
    ES = saddr;
}

# MOV A, ES
:MOV A, ES is opcode=0x8E & A & ES; opcode=0xFD {
    A = ES;
}

# MOV ES = A
:MOV ES, A is opcode=0x9E & A & ES; opcode=0xFD {
    ES = A;
}

# MOV CS, #byte
:MOV CS, "#"data is opcode=0xCE & CS; opcode=0xFC; data {
    CS = data;
}

#
# Table 2/30
#

# MOV A, CS
:MOV A, CS is opcode=0x8E & A & CS; opcode=0xFC {
    A = CS;
}

# MOV CS, A
:MOV CS, A is opcode=0x9E & A & CS; opcode=0xFC {
    CS = A;
}

# MOV A, [DE]
:MOV A, AddrDE is opcode=0x89 & A & AddrDE {
    A = AddrDE;
}

# MOV [DE], A
:MOV AddrDE, A is opcode=0x99 & A & AddrDE {
    AddrDE = A;
}

# MOV [DE+byte], #byte
:MOV AddrDEOffset, "#"data is opcode=0xCA; AddrDEOffset; data {
    AddrDEOffset = data;
}

# MOV A, [DE+byte]
:MOV A, AddrDEOffset is opcode=0x8A & A; AddrDEOffset {
    A = AddrDEOffset;
}

# MOV [DE+byte], A
:MOV AddrDEOffset, A is opcode=0x9A & A; AddrDEOffset {
    AddrDEOffset = A;
}

# MOV A, [HL]
:MOV A, AddrHL is opcode=0x8B & A & AddrHL {
    A = AddrHL;
}

# MOV [HL], A
:MOV AddrHL, A is opcode=0x9B & A & AddrHL {
    AddrHL = A;
}

# MOV [HL+byte], #byte
:MOV AddrHLOffset, u8 is opcode=0xCC; AddrHLOffset; u8 {
    AddrHLOFfset = u8;
}

# MOV A, [HL+byte]
:MOV A, AddrHLOffset is opcode=0x8C & A; AddrHLOffset {
    A = AddrHLOffset;
}

# MOV [HL+byte], A
:MOV AddrHLOffset, A is opcode=0x9C & A; AddrHLOffset {
    AddrHLOffset = A;
}

# MOV A, [HL+B]
:MOV A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xC9 & AddrHLOffsetB {
    A = AddrHLOffsetB;
}

# MOV [HL+B], A
:MOV AddrHLOffsetB, A is opcode=0x61 & A; opcode=0xD9 & AddrHLOffsetB {
    AddrHLOffsetB = A;
}

# MOV A, [HL+C]
:MOV A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xE9 & AddrHLOffsetC {
    A = AddrHLOffsetC;
}

# MOV [HL+C], A
:MOV AddrHLOffsetC, A is opcode=0x61 & A; opcode=0xF9 & AddrHLOffsetC {
    AddrHLOffsetC = A;
}

# MOV word[B], #byte
:MOV AddrWordOffsetB, u8 is opcode=0x19; AddrWordOffsetB; u8 {
    AddrWordOffsetB = u8;
}

# MOV A, word[B]
:MOV A, AddrWordOffsetB is opcode=0x09 & A; AddrWordOffsetB {
    A = AddrWordOffsetB;
}

# MOV word[B], A
:MOV AddrWordOffsetB, A is opcode=0x18 & A; AddrWordOffsetB {
    AddrWordOffsetB = A;
}

# MOV word[C], #byte
:MOV AddrWordOffsetC, u8 is opcode=0x38; AddrWordOffsetC; u8 {
    AddrWordOffsetC = u8;
}

# MOV A, word[C]
:MOV A, AddrWordOffsetC is opcode=0x29 & A; AddrWordOffsetC {
    A = AddrWordOffsetC;
}

# MOV word[C], A
:MOV AddrWordOffsetC, A is opcode=0x28 & A; AddrWordOffsetC {
    AddrWordOffsetC = A;
}

# MOV word[BC], #byte
:MOV AddrWordOffsetBC, u8 is opcode=0x39; AddrWordOffsetBC; u8 {
    AddrWordOffsetBC = u8;
}

# MOV A, word[BC]
:MOV A, AddrWordOffsetBC is opcode=0x49 & A; AddrWordOffsetBC {
    A = AddrWordOffsetBC;
}

# MOV word[BC], A
:MOV AddrWordOffsetBC, A is opcode=0x48 & A; AddrWordOffsetBC {
    AddrWordOffsetBC = A;
}

# MOV [SP+byte], #byte
:MOV AddrSPOffset, u8 is opcode=0xC8; AddrSPOffset; u8 {
    AddrSPOffset = u8;
}

# MOV A, [SP+byte]
:MOV A, AddrSPOffset is opcode=0x88 & A; AddrSPOffset {
    A = AddrSPOffset;
} 

# MOV [SP+byte], A
:MOV AddrSPOffset, A is opcode=0x98 & A; AddrSPOffset {
    AddrSPOffset = A;
}

# MOV B, saddr
:MOV B, saddr is opcode=0xE8 & B; saddr {
    B = saddr;
}

# MOV B, !addr16
:MOV B, addr16 is opcode=0xE9 & B; addr16 {
    B = addr16;
}

# MOV C, saddr
:MOV C, saddr is opcode=0xF8 & C; saddr {
    C = saddr;
}

# MOV C, !addr16
:MOV C, addr16 is opcode=0xF9 & C; addr16 {
    C = addr16;
}

# MOV X, saddr
:MOV X, saddr is opcode=0xD8 & X; saddr {
    X = saddr;
}

# MOV X, !addr16
:MOV X, addr16 is opcode=0xD9 & X; addr16 {
    X = addr16;
}

#
# Table 3/30
#

# XCH A, X
:XCH A, X is opcode=0x08 & A & X {
    inst_xch(A, X);
}

# XCH A, r
:XCH A, sreg2_byte is opcode=0x61; op2_h=0x11 & sreg2_byte & A {
    inst_xch(A, sreg2_byte);
}

# XCH A, saddr
:XCH A, saddr is opcode=0x61 & A; opcode=0xA8; saddr {
    inst_xch(A, saddr);
}

# XCH A, sfr
:XCH A, sfr_byte is opcode=0x61 & A; opcode=0xAB; sfr_byte {
    inst_xch(A, sfr_byte);
}

# XCH A, !addr16
:XCH A, addr16 is opcode=0x61 & A; opcode=0xAA; addr16 {
    inst_xch(A, addr16);
}

# XCH A, [DE]
:XCH A, AddrDE is opcode=0x61 & A; opcode=0xAE & AddrDE {
    inst_xch(A, AddrDE);
}

# XCH A, [DE+byte]
:XCH A, AddrDEOffset is opcode=0x61 & A; opcode=0xAF; AddrDEOffset {
    inst_xch(A, AddrDEOffset);
}

# XCH A, [HL]
:XCH A, AddrHL is opcode=0x61 & A; opcode=0xAC & AddrHL {
    inst_xch(A, AddrHL);
}

# XCH A, [HL+byte]
:XCH A, AddrHLOffset is opcode=0x61 & A; opcode=0xAD; AddrHLOffset {
    inst_xch(A, AddrHLOffset);
}

# XCH A, [HL+B]
:XCH A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xB9 & AddrHLOffsetB {
    inst_xch(A, AddrHLOffsetB);
}

# XCH A, [HL+C]
:XCH A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xA9 & AddrHLOffsetC {
    inst_xch(A, AddrHLOffsetC);
}

#
# Table 4/30
#

# ONEB r
:ONEB dreg_axbc is op_h=0xE & dreg_axbc {
    dreg_axbc = 1;
}

# ONEB saddr
:ONEB saddr is opcode=0xE4; saddr {
    saddr = 1; 
}

# ONEB !addr1s6
:ONEB addr16 is opcode=0xE5; addr16 {
    addr16 = 1;
}

# CLRB r
:CLRB dreg_axbc is op_h=0xF & dreg_axbc {
    dreg_axbc = 0;
}

# CLRB saddr
:CLRB saddr is opcode=0xF4; saddr {
    saddr = 0;
}

# CLRB !addr16
:CLRB addr16 is opcode=0xF5; addr16 {
    addr16 = 0;
}

# MOVS [HL+byte], X
:MOVS X, AddrHLOffset ("Check "A" if zero")is opcode=0x61 & X & A; opcode=0xCE; AddrHLOffset {
    inst_movs(AddrHLOffset);
}

# MOVW rp, #word
:MOVW dreg_word, u16 is op_h=0x3 & dreg_word; u16 {
    dreg_word = u16;
}

# MOVW saddrp, #word
:MOVW saddrp, u16 is opcode=0xC9; saddrp; u16 {
    saddrp = u16;
}

# MOVW sfr, #word
:MOVW sfrpw, u16 is opcode=0xCB; sfrpw; u16 {
    sfrpw = u16;
}

# MOVW AX, saddrp
:MOVW AX, saddrp is opcode=0xAD & AX; saddrp {
    AX = saddrp;
}

# MOVW saddrp, AX
:MOVW saddrp, AX is opcode=0xBD & AX; saddrp {
    saddrp = AX;
}

# MOVW AX, sfrp
:MOVW AX, sfrpw is opcode=0xAE & AX; sfrpw {
    AX = sfrpw;
}

# MOVW sfrp, AX
:MOVW sfrpw, AX is opcode=0xBE & AX; sfrpw {
    sfrpw = AX;
}

# MOVW AX, rp
:MOVW AX, dreg_word is op_h=0x1 & AX & dreg_word & rp_source=1 {
    AX = dreg_word;
}

# MOVW rp, AX
:MOVW dreg_word, AX is op_h=0x1 & AX & dreg_word & rp_source=0 {
    dreg_word = AX;
}

# MOVW AX, !addr16
:MOVW AX, addr16w is opcode=0xAF & AX; addr16w {
    AX = addr16w;
}

# MOVW !addr16, AX
:MOVW addr16w, AX is opcode=0xBF & AX; addr16w {
    addr16w = AX;
}

# MOVW AX, [DE]
:MOVW AX, AddrDEW is opcode=0xA9 & AX & AddrDEW {
    AX = AddrDEW;
}

# MOVW [DE], AX
:MOVW AddrDEW, AX is opcode=0xB9 & AX & AddrDEW {
    AddrDEW = AX;
}

# MOVW AX, [DE+byte]
:MOVW AX, AddrDEOffsetW is opcode=0xAA & AX; AddrDEOffsetW {
    AX = AddrDEOffsetW;
}

# MOVW [DE+byte], AX
:MOVW AddrDEOffsetW, AX is opcode=0xBA & AX; AddrDEOffsetW {
    AddrDEOffsetW = AX;
}

# MOVW AX, [HL]
:MOVW AX, AddrHLW is opcode=0xAB & AX & AddrHLW {
    AX = AddrHLW;
}

# MOVW [HL], AX
:MOVW AddrHLW, AX is opcode=0xBB & AX & AddrHLW {
    AddrHLW = AX;
}

# MOVW AX, [HL+byte]
:MOVW AX, AddrHLOffsetW is opcode=0xAC & AX; AddrHLOffsetW {
    AX = AddrHLOffsetW;
}

# MOVW [HL+byte], AX
:MOVW AddrHLOffsetW, AX is opcode=0xBC & AX; AddrHLOffsetW {
    AddrHLOffsetW = AX;
}

# MOVW AX, word[B]
:MOVW AX, AddrWordOffsetBW is opcode=0x59 & AX; AddrWordOffsetBW {
    AX = AddrWordOffsetBW;
}

#
# Table 5/30
#

# MOVW word[B], AX
:MOVW AddrWordOffsetBW, AX is opcode=0x58 & AX; AddrWordOffsetBW {
    AddrWordOffsetBW = AX;
}

# MOVW AX, word[C]
:MOVW AX, AddrWordOffsetCW is opcode=0x69 & AX; AddrWordOffsetCW {
    AX = AddrWordOffsetCW;
}

# MOVW word[C], AX
:MOVW AddrWordOffsetCW, AX is opcode=0x68 & AX; AddrWordOffsetCW {
    AddrWordOffsetCW = AX;
}

# MOVW AX, word[BC]
:MOVW AX, AddrWordOffsetBCW is opcode=0x79 & AX; AddrWordOffsetBCW {
    AX = AddrWordOffsetBCW;
}

# MOVW AX, [SP+byte]
:MOVW AX, AddrSPOffsetW is opcode=0xA8 & AX; AddrSPOffsetW {
    AX = AddrSPOffsetW;
}

# MOVW [SP+byte], AX
:MOVW AddrSPOffsetW, AX is opcode=0xB8 & AX; AddrSPOffsetW {
    AddrSPOffsetW = AX;
}

# MOVW BC, saddrp
:MOVW BC, saddrp is opcode=0xDA & BC; saddrp {
    BC = saddrp;
}

# MOVW BC, !addr16
:MOVW BC, addr16w is opcode=0xDB & BC; addr16w {
    BC = addr16w;
}

# MOVW DE, saddrp
:MOVW DE, saddrp is opcode=0xEA & DE; saddrp {
    DE = saddrp;
}

# MOVW DE, !addr16
:MOVW DE, addr16w is opcode=0xEB & DE; addr16w {
    DE = addr16w;
}

# MOVW HL, saddrp
:MOVW HL, saddrp is opcode=0xFA & HL; saddrp {
    HL = saddrp;
}

# MOVW HL, !addr16
:MOVW HL, addr16w is opcode=0xFB & HL; addr16w {
    HL = addr16w;
}

# XCHW AX, rp
:XCHW AX, dreg_word is op_h=0x3 & rp_source=1 & dreg_word & AX {
    local tmp = AX;
    AX = dreg_word;
    dreg_word = tmp;
}

# ONEW AX
:ONEW AX is opcode=0xE6 & AX {
    AX = 1;
}

# ONEW BC
:ONEW BC is opcode=0xE7 & BC {
    BC = 1;
}

# CLRW AX
:CLRW AX is opcode=0xF6 & AX {
    AX = 0;
}

# CLRW BC
:CLRW BC is opcode=0xF7 & BC {
    BC = 0;
}

#
# Table 6/30
#

# ADD A, #byte
:ADD A, u8 is opcode=0x0C & A; u8 {
    inst_add(A, u8);
}

# ADD saddr, #byte
:ADD saddr, u8 is opcode=0x0A; saddr; u8 {
    inst_add(saddr, u8);
}

# ADD A, r
:ADD A, sreg2_byte is opcode=0x61 & A; op2_h=0x01 & sreg2_byte {
    inst_add(A, sreg2_byte);
}

# ADD r, A
:ADD sreg2_byte, A is opcode=0x61 & A; op2_h=0x00 & sreg2_byte {
    inst_add(sreg2_byte, A);
}

# ADD A, saddr
:ADD A, saddr is opcode=0x0B & A; saddr {
    inst_add(A, saddr);
}

# ADD A, !addr16
:ADD A, addr16 is opcode=0x0F & A; addr16 {
    inst_add(A, addr16);
}

# ADD A, [HL]
:ADD A, AddrHL is opcode=0x0D & A & AddrHL {
    inst_add(A, AddrHL);
}

# ADD A, [HL+byte]
:ADD A, AddrHLOffset is opcode=0x0E & A; AddrHLOffset {
    inst_add(A, AddrHLOffset);
}

# ADD A, [HL+B]
:ADD A, AddrHLOffsetB is opcode=0x61 & A; opcode=0x80 & AddrHLOffsetB {
    inst_add(A, AddrHLOffsetB);
}

# ADD A, [HL+C]
:ADD A, AddrHLOffsetC is opcode=0x61 & A; opcode=0x82 & AddrHLOffsetC {
    inst_add(A, AddrHLOffsetC);
}

# ADDC A, #byte
:ADDC A, u8 is opcode=0x1C & A; u8 {
    inst_addc(A, u8);
}

# ADDC saddr, #byte
:ADDC saddr, u8 is opcode=0x1A; saddr; u8 {
    inst_addc(saddr, u8);
}

# ADDC A, r
:ADDC A, sreg2_byte is opcode=0x61 & A; op2_h=0x3 & sreg2_byte {
    inst_addc(A, sreg2_byte);
}

# ADDC r, A
:ADDC sreg2_byte, A is opcode=0x61 & A; op2_h=0x2 & sreg2_byte {
    inst_addc(A, sreg2_byte);
}

#
# Table 7/30
#

# ADDC A, saddr
:ADDC A, saddr is opcode=0x1B & A; saddr {
    inst_addc(A, saddr);
}

# ADDC A, !uint16
:ADDC A, addr16 is opcode=0x1F & A; addr16 {
    inst_addc(A, addr16);
}

# ADDC A, [HL]
:ADDC A, AddrHL is opcode=0x1D & A & AddrHL {
    inst_addc(A, AddrHL);
}

# ADDC A, [HL+byte]
:ADDC A, AddrHLOffset is opcode=0x1E & A; AddrHLOffset {
    inst_addc(A, AddrHLOffset);
}

# ADDC A, [HL+B]
:ADDC A, AddrHLOffsetB is opcode=0x61 & A; opcode=0x90 & AddrHLOffsetB {
    inst_addc(A, AddrHLOffsetB);
}

# ADDC A, [HL+C]
:ADDC A, AddrHLOffsetC is opcode=0x61 & A; opcode=0x92 & AddrHLOffsetC {
    inst_addc(A, AddrHLOffsetC);
}

# SUB A, #byte
:SUB A, u8 is opcode=0x2C & A; u8 {
    inst_sub(A, u8);
}

# SUB saddr, #byte
:SUB saddr, u8 is opcode=0x2A; saddr; u8 {
    inst_sub(saddr, u8);
}

# SUB A, r
:SUB A, sreg2_byte is opcode=0x61 & A; op2_h=0x5 & sreg2_byte {
    inst_sub(A, sreg2_byte);
}

# SUB r, A
:SUB sreg2_byte, A is opcode=0x61 & A; op2_h=0x4 & sreg2_byte {
    inst_sub(sreg2_byte, A);
}

# SUB A, saddr
:SUB A, saddr is opcode=0x2B & A; saddr {
    inst_sub(A, saddr);
}

# SUB A, !addr16
:SUB A, addr16 is opcode=0x2F & A; addr16 {
    inst_sub(A, addr16);
}

# SUB A, [HL]
:SUB A, AddrHL is opcode=0x2D & A & AddrHL {
    inst_sub(A, AddrHL);
}

# SUB A, [HL+byte]
:SUB A, AddrHLOffset is opcode=0x2E & A; AddrHLOffset {
    inst_sub(A, AddrHLOffset);
}

# SUB A, [HL+B]
:SUB A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xA0 & AddrHLOffsetB {
    inst_sub(A, AddrHLOffsetB);
}

# SUB A, [HL+C]
:SUB A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xA2 & AddrHLOffsetC {
    inst_sub(A, AddrHLOffsetC);
}

#
# Table 8/30
#

# SUBC A, #byte
:SUBC A, u8 is opcode=0x3C & A; u8 {
    inst_subc(A, u8);
}

# SUBC saddr, #byte
:SUBC saddr, u8 is opcode=0x3A; saddr; u8 {
    inst_subc(saddr, u8);
}

# SUBC A, r
:SUBC A, sreg2_byte is opcode=0x61 & A; op2_h=0x7 & sreg2_byte {
    inst_subc(A, sreg2_byte);
}

# SUBC r, A
:SUBC sreg2_byte, A is opcode=0x61 & A; op2_h=0x6 & sreg2_byte {
    inst_subc(sreg2_byte, A);
}

# SUBC A, saddr
:SUBC A, saddr is opcode=0x3B & A; saddr {
    inst_subc(A, saddr);
}

# SUBC A, !addr16
:SUBC A, addr16 is opcode=0x3F & A; addr16 {
    inst_subc(A, addr16);
}

# SUBC A, [HL]
:SUBC A, AddrHL is opcode=0x3D & A & AddrHL {
    inst_subc(A, AddrHL);
}

# SUBC A, [HL+byte]
:SUBC A, AddrHLOffset is opcode=0x3E & A; AddrHLOffset {
    inst_subc(A, AddrHLOffset);
}

# SUBC A, [HL+B]
:SUBC A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xB0 & AddrHLOffsetB {
    inst_subc(A, AddrHLOffsetB);
}

# SUBC A, [HL+C]
:SUBC A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xB2 & AddrHLOffsetC {
    inst_subc(A, AddrHLOffsetC);
}

# AND A, #byte
:AND A, u8 is opcode=0x5C & A; u8 {
    inst_and(A, u8);
}

# AND saddr, #byte
:AND saddr, u8 is opcode=0x5A; saddr; u8 {
    inst_and(saddr, u8);
}

# AND A, r
:AND A, sreg2_byte is opcode=0x61 & A; op2_h=0xB & sreg2_byte {
    inst_and(A, sreg2_byte);
}

# AND r, A
:AND sreg2_byte, A is opcode=0x61 & A; op2_h=0xA & sreg2_byte {
    inst_and(sreg2_byte, A);
}

#
# Table 9/30
#

# AND A, saddr
:AND A, saddr is opcode=0x5B & A; saddr {
    inst_and(A, saddr);
}

# AND A, !addr16
:AND A, addr16 is opcode=0x5F & A; addr16 {
    inst_and(A, addr16);
}

# AND A, [HL]
:AND A, AddrHL is opcode=0x5D & A & AddrHL {
    inst_and(A, AddrHL);
}

# AND A, [HL+byte]
:AND A, AddrHLOffset is opcode=0x5E & A; AddrHLOffset {
    inst_and(A, AddrHLOffset);
}

# AND A, [HL+B]
:AND A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xD0 & AddrHLOffsetB {
    inst_and(A, AddrHLOffsetB);
}

# AND A, [HL+C]
:AND A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xD2 & AddrHLOffsetC {
    inst_and(A, AddrHLOffsetC);
}

# OR A, #byte
:OR A, u8 is opcode=0x6C & A; u8 {
    inst_or(A, u8);
}

# OR saddr, #byte
:OR saddr, u8 is opcode=0x6A; saddr; u8 {
    inst_or(saddr, u8);
}

# OR A, r
:OR A, sreg2_byte is opcode=0x61 & A; op2_h=0xD & sreg2_byte {
    inst_or(A, sreg2_byte);
}

# OR r, A
:OR sreg2_byte, A is opcode=0x61 & A; op2_h=0xC & sreg2_byte {
    inst_or(sreg2_byte, A);
}

# OR A, saddr
:OR A, saddr is opcode=0x6B & A; saddr {
    inst_or(A, saddr);
}

# OR A, !addr16
:OR A, addr16 is opcode=0x6F & A; addr16 {
    inst_or(A, addr16);
}

# OR A, [HL]
:OR A, AddrHL is opcode=0x6D & A & AddrHL {
    inst_or(A, AddrHL);
}

# OR A, [HL+byte]
:OR A, AddrHLOffset is opcode=0x6E & A; AddrHLOffset {
    inst_or(A, AddrHLOffset);
}

# OR A, [HL+B]
:OR A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xE0 & AddrHLOffsetB {
    inst_or(A, AddrHLOffsetB);
}

# OR A, [HL+C]
:OR A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xE2 & AddrHLOffsetC {
    inst_or(A, AddrHLOffsetC);
}

#
# Table 10/30
#

# XOR A, #byte
:XOR A, u8 is opcode=0x7C & A; u8 {
    inst_xor(A, u8);
}

# XOR saddr, #byte
:XOR saddr, u8 is opcode=0x7A; saddr; u8 {
    inst_xor(saddr, u8);
}

# XOR A, r
:XOR A, sreg2_byte is opcode=0x61 & A; op2_h=0xf & sreg2_byte {
    inst_xor(A, sreg2_byte);
}

# XOR r, A
:XOR sreg2_byte, A is opcode=0x61 & A; op2_h=0xe & sreg2_byte {
    inst_xor(sreg2_byte, A);
}

# XOR A, saddr
:XOR A, saddr is opcode=0x7B & A; saddr {
    inst_xor(A, saddr);
}

# XOR A, !addr16
:XOR A, addr16 is opcode=0x7f & A; addr16 {
    inst_xor(A, addr16);
}

# XOR A, [HL]
:XOR A, AddrHL is opcode=0x7D & A & AddrHL {
    inst_xor(A, AddrHL);
}

# XOR A, [HL+byte]
:XOR A, AddrHLOffset is opcode=0x7E & A; AddrHLOffset {
    inst_xor(A, AddrHLOffset);
}

# XOR A, [HL+B]
:XOR A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xF0 & AddrHLOffsetB {
    inst_xor(A, AddrHLOffsetB);
}

# XOR A, [HL+C]
:XOR A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xF2 & AddrHLOffsetC {
    inst_xor(A, AddrHLOffsetC);
}

# CMP A, #byte
:CMP A, u8 is opcode=0x4C & A; u8 {
    inst_cmp(A, u8);
}

# CMP saddr, #byte
:CMP saddr, u8 is opcode=0x4A; saddr; u8 {
    inst_cmp(saddr, u8);
}

# NOTE: Similar to XOR above, CMP can be simplified by looking
# at the 5 upper bits of the second byte of the instruction.
# 0x48 -> 0x9

# CMP A, r
:CMP A, sreg2_byte is opcode=0x61 & A; op2_h=0x9 & sreg2_byte {
    inst_cmp(A, sreg2_byte);
}

# CMP r, A
:CMP sreg2_byte, A is opcode=0x61 & A; op2_h=0x8 & sreg2_byte {
    inst_cmp(sreg2_byte, A);
}

#
# Table 11/30
#

# CMP A, saddr
:CMP A, saddr is opcode=0x4B & A; saddr {
    inst_cmp(A, saddr);
}

# CMP A, !addr16
:CMP A, addr16 is opcode=0x4F & A; addr16 {
    inst_cmp(A, addr16);
}

# CMP A, [HL]
:CMP A, AddrHL is opcode=0x4D & A & AddrHL {
    inst_cmp(A, AddrHL);
}

# CMP A, [HL+byte]
:CMP A, AddrHLOffset is opcode=0x4E & A; AddrHLOffset {
    inst_cmp(A, AddrHLOffset);
}

# CMP A, [HL+B]
:CMP A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xC0 & AddrHLOffsetB {
    inst_cmp(A, AddrHLOffsetB);
}

# CMP A, [HL+C]
:CMP A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xC2 & AddrHLOffsetC {
    inst_cmp(A, AddrHLOffsetC);
}

# CMP !addr16, #byte
:CMP addr16, u8 is opcode=0x40; addr16; u8 {
    inst_cmp(addr16, u8);
}

# CMP0, r
:CMP0 dreg_axbc is op_h=0xD & dreg_axbc {
    inst_cmp0(dreg_axbc);
}

# CMP0 saddr
:CMP0 saddr is opcode=0xD4; saddr {
    inst_cmp0(saddr);
}

# CMP0 !addr16
:CMP0 addr16 is opcode=0xD5; addr16 {
    inst_cmp0(addr16);
}

# CMPS X, [HL+byte]
:CMPS X, AddrHLOffset is opcode=0x61 & X; opcode=0xDE; AddrHLOffset {
    inst_cmps(X, AddrHLOffset);
}

# ADDW AX, #word
:ADDW AX, u16 is opcode=0x04 & AX; u16 {
    inst_addw(AX, u16);
}

# ADDW AX, rp
:ADDW AX, dreg_word is op_h=0x0 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_addw(AX, dreg_word);
}

# ADDW AX, saddrp
:ADDW AX, saddrp is opcode=0x06 & AX; saddrp {
    inst_addw(AX, saddrp);
}

# ADDW AX, !addr16
:ADDW AX, addr16w is opcode=0x02 & AX; addr16w {
    inst_addw(AX, addr16w);
}

# ADDW AX, [HL+byte]
:ADDW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x09; AddrHLOffsetW {
    inst_addw(AX, AddrHLOffsetW);
}

# SUBW AX, #word
:SUBW AX, u16 is opcode=0x24 & AX; u16 {
    inst_subw(AX, u16);
}

# SUBW AX, rp
:SUBW AX, dreg_word is op_h=0x2 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_subw(AX, dreg_word);
}

# SUBW AX, saddrp
:SUBW AX, saddrp is opcode=0x26 & AX; saddrp {
    inst_subw(AX, saddrp);
}

# SUBW AX, !addr16
:SUBW AX, addr16w is opcode=0x22 & AX; addr16w {
    inst_subw(AX, addr16w);
}

# SUBW AX, [HL+byte]
:SUBW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x29; AddrHLOffsetW {
    inst_subw(AX, AddrHLOffsetW);
}

#
# Table 12/30
#

# CMPW AX, #word
:CMPW AX, u16 is opcode=0x44 & AX; u16 {
    inst_cmpw(AX, u16);
}

# CMPW AX, rp
:CMPW AX, dreg_word is op_h=0x4 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_cmpw(AX, dreg_word);
}

# CMPW AX, saddrp
:CMPW AX, saddrp is opcode=0x46 & AX; saddrp {
    inst_cmpw(AX, saddrp);
}

# CMPW AX, !addr16
:CMPW AX, addr16w is opcode=0x42 & AX; addr16w {
    inst_cmpw(AX, addr16w);
}

# CMPW AX, [HL+byte]
:CMPW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x49; AddrHLOffsetW {
    inst_cmpw(AX, AddrHLOffsetW);
}

# MULU X
:MULU X (AX"="A"*X") is opcode=0xD6 & AX & X & A {
    local aw:2 = zext(A:1);
    local xw:2 = zext(X:1);
    AX = aw * xw;
}

# MULHU
:MULHU ("AXBC="AX"*"BC) is opcode=0xCE; opcode=0xFB; opcode=0x01 & AX & BC {
    local axdw:4 = zext(AX:2);
    local bcdw:4 = zext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# MULH
:MULH ("AXBC="AX"*"BC) is opcode=0xCE; opcode=0xFB; opcode=0x02 & AX & BC {
    local axdw:4 = sext(AX:2);
    local bcdw:4 = sext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2; 
}

# DIVHU
:DIVHU ("AXDE="AX"/"DE) is opcode=0xCE; opcode=0xFB; opcode=0x03 & AX & DE {
    local axdw:4 = zext(AX:2);
    local dedw:4 = zext(DE:2);

    # Doesn't handle the case where DE is 0
    local div:4 = axdw / dedw;
    local rem:4 = axdw % dedw;

    dedw = div & 0xFFFF;
    axdw = rem & 0xFFFF;

    DE = dedw:2;
    AX = axdw:2;
}

# DIVWU
:DIVWU is opcode=0xCE; opcode=0xFB; opcode=0x04 { divwu(); }

# MACHU
:MACHU is opcode=0xCE; opcode=0xFB; opcode=0x05 { machu(); }

# MACH
:MACH is opcode=0xCE; opcode=0xFB; opcode=0x06 { mach(); }

# INC r
:INC dreg_byte is op_h=0x8 & dreg_byte {
    inst_inc(dreg_byte);
}

# INC saddr
:INC saddr is opcode=0xA4; saddr {
    inst_inc(saddr);
}

# INC !addr16
:INC addr16 is opcode=0xA0; addr16 {
    inst_inc(addr16);
}

# INC [HL+byte]
:INC AddrHLOffset is opcode=0x61; opcode=0x59; AddrHLOffset {
    inst_inc(AddrHLOffset);
}

# DEC r
:DEC dreg_byte is op_h=0x9 & dreg_byte {
    inst_dec(dreg_byte);
}

# DEC saddr
:DEC saddr is opcode=0xB4; saddr {
    inst_dec(saddr);
}

# DEC !addr16
:DEC addr16 is opcode=0xB0; addr16 {
    inst_dec(addr16);
}

# DEC [HL+byte]
:DEC AddrHLOffset is opcode=0x61; opcode=0x69; AddrHLOffset {
    inst_dec(AddrHLOffset);
}

#
# Table 13
#

# INCW rp
:INCW dreg_word is op_h=0xA & dreg_word {
    inst_incw(dreg_word);
}

# INCW saddrp
:INCW saddrp is opcode=0xA6; saddrp {
    inst_incw(saddrp);
}

# INCW !addr16
:INCW addr16w is opcode=0xA2; addr16w {
    inst_incw(addr16w);
}

# INCW [HL+byte]
:INCW AddrHLOffsetW is opcode=0x61; opcode=0x79; AddrHLOffsetW {
    inst_incw(AddrHLOffsetW);
}

# DECW rp
:DECW dreg_word is op_h=0xB & dreg_word {
    inst_decw(dreg_word);
}

# DECW saddrp
:DECW saddrp is opcode=0xB6; saddrp {
    inst_decw(saddrp);
}

# DECW !addr16
:DECW addr16w is opcode=0xB2; addr16w {
    inst_decw(addr16w);
}

# DECW [HL+byte]
:DECW AddrHLOffset is opcode=0x61; opcode=0x89; AddrHLOffset {
    inst_decw(AddrHLOffset);
}

# SHR A, n
:SHR A, shr_n is opcode=0x31 & A; op2_l=0xA & shr_n {
    inst_shr(A, shr_n);
}

# SHRW AX, n
:SHRW AX, shr_n is opcode=0x31 & AX; op2_l=0xE & shr_n {
    inst_shr(AX, shr_n);
}
