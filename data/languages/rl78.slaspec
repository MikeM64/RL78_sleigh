#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg
#
# MikeM64, 2020
#########################################################################

#
# Current TODO list:
#   - Prefix instructions
#   - Rest of the manual...
#

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 wordsize=1 default;
define space stackarea  type=ram_space      size=2;
define space register   type=register_space size=1;

# General Purpose registers
define register offset=0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit-mode bank3
define register offset=0x00 size=2 [AX3   BC3   DE3   HL3  ];  #16-bit-mode bank3
define register offset=0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit-mode bank2
define register offset=0x08 size=2 [AX2   BC2   DE2   HL2  ];  #16-bit-mode bank2
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit-mode bank1
define register offset=0x10 size=2 [AX1   BC1   DE1   HL1  ];  #16-bit-mode bank1
define register offset=0x18 size=1 [X  A  C  B  E  D  L  H ];  # 8-bit-mode bank0
define register offset=0x18 size=2 [AX    BC    DE    HL   ];  #16-bit-mode bank0

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x60 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z RBS1 AC RBS0 ISP1 ISP0 CY];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    opcode = (0, 7)
    op_h = (4, 7)
    dreg_byte = (0, 2)
    dreg_axbc = (0, 1)
    sreg_byte = (0, 2);
attach variables [ dreg_byte sreg_byte ] [X A C B E D L H];
attach variables [ dreg_axbc ] [X A C B];

define token data8 (8)
    data = (0, 7)
    uaddr8 = (0, 7);

define token data16 (16)
    uaddr16 = (0, 15);

#########################################################################
#
# Instruction macros
#
#########################################################################

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

#########################################################################
#
# Root table constructors
#
#########################################################################

saddr: loc is uaddr8 [ loc = 0xFFE00 + uaddr8; ] {
    export *:1 loc;
}

addr16: loc is uaddr16 [ loc = 0xF0000 + uaddr16; ] {
    export *:1 loc;
}

#########################################################################
#
# Root table instructions
#
#########################################################################

:NOP is opcode=0x00 {}

:HALT is opcode=0x61; opcode=0xED { halt(); }

:STOP is opcode=0x61; opcode=0xFD { stop(); }

# MOV r, #byte
:MOV dreg_byte, "#"data is op_h=0x5 & dreg_byte; data {
    dreg_byte = data;
}

# MOV A, r
:MOV A, sreg_byte is op_h=0x6 & A & sreg_byte {
    A = sreg_byte;
}

# MOV r, A
:MOV dreg_byte, A is op_h=0x7 & A & dreg_byte {
    dreg_byte = A;
}

# MOV saddr, #byte
:MOV saddr, "#"data is opcode=0xCD; saddr; data {
    saddr = data;
}

# INC r
:INC dreg_byte is op_h=0x8 & dreg_byte {
    inst_inc(dreg_byte);
}

# DEC r
:DEC dreg_byte is op_h=0x9 & dreg_byte {
    inst_dec(dreg_byte);
}

# ONEB r
:ONEB dreg_axbc is op_h=0xE & dreg_axbc {
    dreg_axbc = 1;
}

# ONEB saddr
:ONEB saddr is opcode=0xE4; saddr {
    saddr = 1; 
}

# ONEB !addr1s6
:ONEB "!"addr16 is opcode=0xE5; addr16 {
    addr16 = 1;
}

# CLRB r
:CLRB dreg_axbc is op_h=0xF & dreg_axbc {
    dreg_axbc = 0;
}

# CLRB saddr
:CLRB saddr is opcode=0xF4; saddr {
    saddr = 0;
}

# CLRB !addr16
:CLRB "!"addr16 is opcode=0xF5; addr16 {
    addr16 = 0;
}
