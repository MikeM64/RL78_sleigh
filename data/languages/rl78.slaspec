#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg and aerosoul94
#
# MikeM64, 2020
#########################################################################

#
# Current TODO list:
#   - Prefix instructions
#   - Rest of the manual...
#

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 wordsize=1 default;
define space stackarea  type=ram_space      size=2;
define space register   type=register_space size=1;

# General Purpose registers
define register offset=0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit-mode bank3
define register offset=0x00 size=2 [AX3   BC3   DE3   HL3  ];  #16-bit-mode bank3
define register offset=0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit-mode bank2
define register offset=0x08 size=2 [AX2   BC2   DE2   HL2  ];  #16-bit-mode bank2
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit-mode bank1
define register offset=0x10 size=2 [AX1   BC1   DE1   HL1  ];  #16-bit-mode bank1
define register offset=0x18 size=1 [X  A  C  B  E  D  L  H ];  # 8-bit-mode bank0
define register offset=0x18 size=2 [AX    BC    DE    HL   ];  #16-bit-mode bank0

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x60 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z RBS1 AC RBS0 ISP1 ISP0 CY];

# Implementation-specific special function registers, starting from 0xFFF00
define ram offset=0xFFF00 size=1 [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    opcode = (0, 7)
    op_h = (4, 7)
    op_l = (0, 3)
    dreg_byte = (0, 2)
    dreg_axbc = (0, 1)
    sreg_byte = (0, 2);
attach variables [ dreg_byte sreg_byte ] [X A C B E D L H];
attach variables [ dreg_axbc ] [X A C B];

define token base2 (8)
    op2_h = (3, 7)
    sreg2_byte = (0, 2);
attach variables [ sreg2_byte ] [X A C B E D L H];

define token data8 (8)
    data        = (0, 7)
    uaddr8      = (0, 7)
    sfr_byte    = (0, 7);
attach variables [ sfr_byte ] [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

define token data16 (16)
    uaddr16 = (0, 15);

#########################################################################
#
# Instruction macros
#
#########################################################################

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

macro inst_xor(dst, src) {
    dst = dst ^ src;
    Z = (dst == 0);
}

macro inst_cmp(dst, src) {
    Z = (dst - src) == 0;
    AC = (dst & 0x08) > (src & 0x08);
    CY = (dst & 0x80) > (src & 0x80);
}

macro update_psw(data) {
    # Update PSW as expected
    PSW         = data;
    # Then split it apart into the shadow registers
    # for use during decompilation
    IE     = (data & 0x80) >> 7;
    Z      = (data & 0x40) >> 6;
    RBS1   = (data & 0x20) >> 5;
    AC     = (data & 0x10) >> 4;
    RBS0   = (data & 0x08) >> 3;
    ISP1   = (data & 0x04) >> 2;
    ISP0   = (data & 0x02) >> 1;
    CY     = (data & 0x01);
}

#########################################################################
#
# Root table constructors
#
#########################################################################

# Instruction data tokens

u8: "#"data is data {
    local tmp:1 = data;
    export tmp;
}

saddr: loc is uaddr8 [ loc = 0xFFE00 + uaddr8; ] {
    export *:1 loc;
}

addr16: "!"loc is uaddr16 [ loc = 0xF0000 + uaddr16; ] {
    export *:1 loc;
}

sfrp: loc is sfr_byte [ loc = 0xFFF00 + sfr_byte; ] {
    export *:1 loc;
}

# Register Ponter tokens - [r]

AddrDE: [DE] is DE {
    local loc:3 = zext(DE);
    export *:1 loc;
}

AddrDEOffset: [DE+uaddr8] is DE & uaddr8 {
    local loc:3 = zext(DE) + uaddr8;
    export *:1 loc;
}

AddrHL: [HL] is HL {
    local loc:3 = zext(HL);
    export *:1 loc;
}

AddrHLOffset: [HL+uaddr8] is HL & uaddr8 {
    local loc:3 = zext(HL) + uaddr8;
    export *:1 loc;
}

AddrHLOffsetB: [HL+B] is HL & B {
    local loc:3 = zext(HL) + zext(B);
    export *:1 loc;
}

AddrHLOffsetC: [HL+C] is HL & C {
    local loc:3 = zext(HL) + zext(C);
    export *:1 loc;
}

#########################################################################
#
# Root table instructions
#
#########################################################################

:NOP is opcode=0x00 {}

:HALT is opcode=0x61; opcode=0xED { halt(); }

:STOP is opcode=0x61; opcode=0xFD { stop(); }

#
# Table 1/30
#

# MOV r, #byte
:MOV dreg_byte, "#"data is op_h=0x5 & dreg_byte; data {
    dreg_byte = data;
}

# MOV A, r
:MOV A, sreg_byte is op_h=0x6 & A & sreg_byte {
    A = sreg_byte;
}

# MOV r, A
:MOV dreg_byte, A is op_h=0x7 & A & dreg_byte {
    dreg_byte = A;
}

# MOV saddr, #byte
:MOV saddr, "#"data is opcode=0xCD; saddr; data {
    saddr = data;
}

# MOV sfr, #byte
:MOV sfr_byte, "#"data is opcode=0xCE; sfr_byte; data {
    sfr_byte = data;
}

# MOV !addr16, #byte
:MOV addr16, "#"data is opcode=0xCF; addr16; data {
    addr16 = data;
}

# MOV A, saddr
:MOV A, saddr is opcode=0x8D & A; saddr {
    A = saddr;
}

# MOV saddr, A
:MOV saddr, A is opcode=0x9D & A; saddr {
    saddr = A;
}

# MOV A, sfr
:MOV A, sfrp is opcode=0x8E & A; sfrp {
    A = sfrp;
}

# MOV sfr, A
:MOV sfrp, A is opcode=0x9E & A; sfrp {
    sfrp = A;
}

# MOV A, !addr16
:MOV A, addr16 is opcode=0x8F & A; addr16 {
    A = addr16;
}

# MOV !addr16, A
:MOV addr16, A is opcode=0x9F & A; addr16 {
    addr16 = A;
}

# MOV PSW, #byte
:MOV PSW, "#"data is opcode=0x9F & PSW; opcode=0xFA; data {
    update_psw(data);
}

# MOV A, PSW
:MOV A, PSW is opcode=0x8E & A & PSW; opcode=0xFA {
    A = PSW;
}

# MOV PSW, A
:MOV PSW, A is opcode=0x9E & A & PSW; opcode=0xFA {
    update_psw(A);
}

# MOV ES, #byte
:MOV ES, "#"data is opcode=0x41 & ES; data {
    ES = data;
}

# MOV ES, saddr
:MOV ES, saddr is opcode=0x61 & ES; opcode=0xB8; saddr {
    ES = saddr;
}

# MOV A, ES
:MOV A, ES is opcode=0x8E & A & ES; opcode=0xFD {
    A = ES;
}

# MOV ES = A
:MOV ES, A is opcode=0x9E & A & ES; opcode=0xFD {
    ES = A;
}

# MOV CS, #byte
:MOV CS, "#"data is opcode=0xCE & CS; opcode=0xFC; data {
    CS = data;
}

#
# Table 2/30
#

# MOV A, CS
:MOV A, CS is opcode=0x8E & A & CS; opcode=0xFC {
    A = CS;
}

# MOV CS, A
:MOV CS, A is opcode=0x9E & A & CS; opcode=0xFC {
    CS = A;
}

# MOV A, [DE]
:MOV A, AddrDE is opcode=0x89 & A & AddrDE {
    A = AddrDE;
}

# MOV [DE], A
:MOV AddrDE, A is opcode=0x99 & A & AddrDE {
    AddrDE = A;
}

# MOV [DE+byte], #byte
:MOV AddrDEOffset, "#"data is opcode=0xCA; AddrDEOffset; data {
    AddrDEOffset = data;
}

# MOV A, [DE+byte]
:MOV A, AddrDEOffset is opcode=0x8A & A; AddrDEOffset {
    A = AddrDEOffset;
}

# MOV [DE+byte], A
:MOV AddrDEOffset, A is opcode=0x9A & A; AddrDEOffset {
    AddrDEOffset = A;
}

#
# Table 4/30
#

# ONEB r
:ONEB dreg_axbc is op_h=0xE & dreg_axbc {
    dreg_axbc = 1;
}

# ONEB saddr
:ONEB saddr is opcode=0xE4; saddr {
    saddr = 1; 
}

# ONEB !addr1s6
:ONEB addr16 is opcode=0xE5; addr16 {
    addr16 = 1;
}

# CLRB r
:CLRB dreg_axbc is op_h=0xF & dreg_axbc {
    dreg_axbc = 0;
}

# CLRB saddr
:CLRB saddr is opcode=0xF4; saddr {
    saddr = 0;
}

# CLRB !addr16
:CLRB addr16 is opcode=0xF5; addr16 {
    addr16 = 0;
}

#
# Table 5/30
#

# ONEW AX
:ONEW AX is opcode=0xE6 & AX {
    AX = 1;
}

# ONEW BC
:ONEW BC is opcode=0xE7 & BC {
    BC = 1;
}

# CLRW AX
:CLRW AX is opcode=0xF6 & AX {
    AX = 0;
}

# CLRW BC
:CLRW BC is opcode=0xF7 & BC {
    BC = 0;
}

#
# Table 10/30
#

# XOR A, #byte
:XOR A, u8 is opcode=0x7C & A; u8 {
    inst_xor(A, u8);
}

# XOR saddr, #byte
:XOR saddr, u8 is opcode=0x7A; saddr; u8 {
    inst_xor(saddr, u8);
}

# NOTE: The following XOR instructions differ by a single bit
# The high 5 bits of the second byte of the opcode get shifted
# by 3 bits when extracted from the byte. 0x78 >> 3 -> 0xf

# XOR A, r
:XOR A, sreg2_byte is opcode=0x61 & A; op2_h=0xf & sreg2_byte {
    inst_xor(A, sreg2_byte);
}

# XOR r, A
:XOR sreg2_byte, A is opcode=0x61 & A; op2_h=0xe & sreg2_byte {
    inst_xor(sreg2_byte, A);
}

# XOR A, saddr
:XOR A, saddr is opcode=0x7B & A; saddr {
    inst_xor(A, saddr);
}

# XOR A, !addr16
:XOR A, addr16 is opcode=0x7f & A; addr16 {
    inst_xor(A, addr16);
}

# XOR A, [HL]
:XOR A, AddrHL is opcode=0x7D & A & AddrHL {
    inst_xor(A, AddrHL);
}

# XOR A, [HL+byte]
:XOR A, AddrHLOffset is opcode=0x7E & A; AddrHLOffset {
    inst_xor(A, AddrHLOffset);
}

# XOR A, [HL+B]
:XOR A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xF0 & AddrHLOffsetB {
    inst_xor(A, AddrHLOffsetB);
}

# XOR A, [HL+C]
:XOR A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xF2 & AddrHLOffsetC {
    inst_xor(A, AddrHLOffsetC);
}

# CMP A, #byte
:CMP A, u8 is opcode=0x4C & A; u8 {
    inst_cmp(A, u8);
}

# CMP saddr, #byte
:CMP saddr, u8 is opcode=0x4A; saddr; u8 {
    inst_cmp(saddr, u8);
}

# NOTE: Similar to XOR above, CMP can be simplified by looking
# at the 5 upper bits of the second byte of the instruction.
# 0x48 -> 0x9

# CMP A, r
:CMP A, sreg2_byte is opcode=0x61 & A; op2_h=0x9 & sreg2_byte {
    inst_cmp(A, sreg2_byte);
}

# CMP r, A
:CMP sreg2_byte, A is opcode=0x61 & A; op2_h=0x8 & sreg2_byte {
    inst_cmp(sreg2_byte, A);
}

#
# Table 12/30
#

# INC r
:INC dreg_byte is op_h=0x8 & dreg_byte {
    inst_inc(dreg_byte);
}

# INC saddr
:INC saddr is opcode=0xA4; saddr {
    inst_inc(saddr);
}

# INC !addr16
:INC addr16 is opcode=0xA0; addr16 {
    inst_inc(addr16);
}

# INC [HL+byte]
:INC AddrHLOffset is opcode=0x61; opcode=0x59; AddrHLOffset {
    inst_inc(AddrHLOffset);
}

# DEC r
:DEC dreg_byte is op_h=0x9 & dreg_byte {
    inst_dec(dreg_byte);
}

# DEC saddr
:DEC saddr is opcode=0xB4; saddr {
    inst_dec(saddr);
}

# DEC !addr16
:DEC addr16 is opcode=0xB0; addr16 {
    inst_dec(addr16);
}

# DEC [HL+byte]
:DEC AddrHLOffset is opcode=0x61; opcode=0x69; AddrHLOffset {
    inst_dec(AddrHLOffset);
}
