##########################################################################
#
# Attempt at implementing the RL78
# 16-bit MCU ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

define endian=little;
define alignment=1;

@define PTRSIZE "3"

define space ram 		type=ram_space		size=$(PTRSIZE) 	default;
define space register 	type=register_space size=1;



#general purpose registers:
define register offset= 0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3]; 	# 8-bit-mode bank3
define register offset= 0x00 size=2 [AX3   BC3   DE3   HL3];	#16-bit-mode bank3
define register offset= 0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2]; 	# 8-bit-mode bank2
define register offset= 0x08 size=2 [AX2   BC2   DE2   HL2];	#16-bit-mode bank2
define register offset= 0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1]; 	# 8-bit-mode bank1
define register offset= 0x10 size=2 [AX1   BC1   DE1   HL1];	#16-bit-mode bank1
define register offset= 0x18 size=1 [X  A  C  B  E  D  L  H]; 	# 8-bit-mode bank0
define register offset= 0x18 size=2 [AX    BC    DE    HL];	 	#16-bit-mode bank0
define register offset= 0x20 size=1 [RB0 RB1 RB2 RB3];			#dummy args for register banks

#special purpose registers
define register offset=0x40 size=4 [PC]; #I Think this is right??? they don't specify
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];

#Flag bits
#Macros? I think? to make accessing the bits in the PSW easier
@define IE_flag 	"PSW[7,1]"	# Interrupt Enable (IE)
@define Z_flag  	"PSW[6,1]" 	# Zero Flag (Z)
@define RBS1_flag   "PSW[5,1]"	# Register Bank Select Hi-Bit (RBS1)
@define AC_flag 	"PSW[4,1]"  # Auxiliary Carry Flag (AC)
@define RBS0_flag	"PSW[3,1]" 	# Register Bank Select Lo-Bit (RBS0)
@define ISP1_flag 	"PSW[2,1]" 	# In-service priority flag Hi-Bit (ISP1)
@define ISP0_flag 	"PSW[1,1]"  # In-service priority flag Lo-Bit (ISP0)
@define CY_flag 	"PSW[0,1]"  # Carry flag (CY)

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop skip;

#########################################################################
#
# Operand data types
#
# FYI: You can think of sleigh tokens as both bitfields and parser 
# 	   directives. Basically, a token is any element that is a potential
# 	   sub-field you may want to parse out of an instruction, and the 
# 	   attach keyword is used to turn those parsed fields into
#	   elements of a register map cleanly.
#
#########################################################################

define token op1b (8) 
	op1b_byte = (0,7)

	op1b_hi = (4,7)
	op1b_lo = (0,3)
	op1b_lo3 = (0,2)

	op1b_reg0 = (0,2)
	op1b_reg_4_5 = (4,5)
	op1b_reg0_dupe = (0,2)
	op1b_2xreg = (1,2)
	op1b_2xreg_dupe = (1,2) #duplicate to check val
	op1b_reg_dehl = (1,1) #special namespace for mov operations
					   #which are limited to DE and HL r/w.
					   #This includes all mem load/store ops.
	op1b_reg_axbc = (0,0) #special namespace for clrw & co, only uses ax/bc
	op1b_movw_rp = (4,5)
	op1b_movw_rp_dupe = (4,5)
	op1b_reg_rp = (1,2)

	op1b_b7 = (7,7)
	op1b_b6 = (6,6)
	op1b_b5 = (5,5)
	op1b_b4 = (4,4)
	op1b_b3 = (3,3)
	op1b_b2 = (2,2)
	op1b_b1 = (1,1)
	op1b_b0 = (0,0)
;

define token op2b (8)
	op2b_byte = (0,7)
	op2b_hi = (4,7)
	op2b_hi_val = (4,7) #duplicate to check val without causing issues
	op2b_lo = (0,3)
	op2b_sfr = (0,2)
	op2b_sfrp = (0,1)

	op2b_b7 = (7,7)
	op2b_b3 = (3,3)
	op2b_b2 = (2,2)

	op2b_reg0 = (0,2)
	op2b_reg0_dupe = (0,2)
	op2b_reg_rbsel = (4,5)

	op2b_hi2 = (6,7)
	op2b_bit_sel = (4,6)
;

define token op3b (8)	
	op3b_byte0 = (0,7)
	op3b_sfr = (0,2)
	op3b_hi = (4,7)
	op3b_lo = (0,3)
	op3b_b3 = (3,3)
;

define token esbyte (8)
	esmarker = (0,7)
;

define token data8 (8)
	adr8_dupe = (0,7)
	adr8 = (0,7) signed
	imm8 = (0,7)
	simm8 = (0,7) signed
;

define token data16 (16)
	imm16 = (0,15)
	imm16_lo = (0,7)
	imm16_hi = (8,15)
	simm16 = (0,15) signed
;

define token data24 (24)
	imm24 = (0,23)
;

attach variables [op1b_reg0 op2b_reg0] 	[X A C B E D L H];
attach variables [op1b_2xreg]			[AX BC DE HL];
attach variables [op2b_sfr op3b_sfr]	[SPL SPH PSW _ CS ES PMC MEM];
attach variables [op1b_reg_dehl]		[DE HL];
attach variables [op1b_reg_axbc]		[AX BC];
attach variables [op2b_sfrp]			[SP      _     _     _      ];
attach variables [op1b_reg_4_5]			[_ B C _];
attach variables [op1b_reg_rp]			[_ DE HL _];
attach variables [op1b_movw_rp]			[_ BC DE HL];

##########################################################################
#
# Macros
#
##########################################################################

#macro push16(val16) {
#	SP = SP - 2;
#	ptr:$(PTRSIZE) = SP;
#	*:2 ptr = val16; 
#}



macro addw_set_flags(val1, val2){
	local tmp1:2;
	local tmp2:2;
	tmp1 = (val1>>15)&0x1;
	tmp2 = (val2>>15)&0x1;
	$(CY_flag) = tmp1[0,1] & tmp2[0,1];
	$(Z_flag) = (val1 == (-val2));
	$(AC_flag) = 0;
}

macro add_set_flags(val1, val2){
	$(CY_flag) = ((val1>>7)&0x1) & ((val2>>7)&0x1);
	$(Z_flag)  = (val1 == (-val2));
	local tmp:1 = 0x0;
	tmp = val1[0,3] + val2[0,3];
	tmp = (tmp >> 3) & 0x1;
	$(AC_flag) = tmp;
}

macro sr_set_flags16(reg, imm){
	local tmp:2 = (reg >> imm) & 0x1:2;
	local tmp2:1 = tmp[0,7];
	$(CY_flag) = tmp2;
}

macro sr_set_flags8(reg, imm){
	local tmp:1 = (reg >> imm) & 0x1:1;
	$(CY_flag) = tmp;
}

macro read_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_stack_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_es_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = ptr[0, 16] | addr;
	ptr[16, 4] = ptr[16, 4] | ES[0, 4];
	dst = *:1 ptr;
}

macro write_byte(src, addr){
	ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0,16] = ptr[0,16] | addr;
	*:1 ptr = src;
}

macro write_stack_byte(src, addr){
	local ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0, 16] = addr[0,16];
	*:1 ptr = src;
}

#macro write_es_byte(src, addr){}

#TODO: check if base for mem reads is 0xF or 0x0, 
#		datasheet and ODA seem to disagree. 
macro read_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro write_word(src, addr){
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro write_stack_word(src, addr){
	#TODO: replace all write_stack_word uses with push_word uses
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro push_word(src, stackp){
	stackp = stackp - 2;
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = stackp[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}


macro read_stack_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr;
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro pop_word(dst, stackp){
	#TODO: replace all read_stack_word uses with pop_word
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = stackp[0,16];
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
	stackp = stackp + 2;
}

macro cmp8_set_flags(arg1, arg2){
	$(Z_flag) = ((arg2 - arg1) == 0);
	$(CY_flag) = ((arg2 & 0x7f) < (arg1 & 0x7f));
	$(AC_flag) = ((arg2 & 0x07) < (arg1 & 0x07));
}

macro cmpw_set_flags(arg1, arg2){
	$(Z_flag) = (arg2 == arg1);
}

macro bit_set_to(val, bit_index, set_to){
	local mask = ~(0x1 << bit_index);
	val = val & mask;
	val = val|(set_to<<bit_index);
}

macro bit_get(val, bit_index, dst){
	local tmp = (val>>bit_index);
	dst = (tmp & 0x1);
}

macro reg_stackarea_offset8(saptr, ptr_reg, adr){
	saptr = 0x0F0000;
	local tmp:3 = saptr | zext(ptr_reg);
	saptr = tmp + adr;
}

RelAddr8: loc  is simm8  [ loc = inst_next + simm8; ]        
		{ export *:$(PTRSIZE) loc; }

addr16:   loc is imm16 [ loc = 0xf0000 + imm16;]	
		{ export *:$(PTRSIZE) loc; }

jaddr16:  loc is imm16 [ loc = 0x00000 | imm16;]
		{ export *:1 loc; }

jaddr20: loc is imm24 [ loc = imm24&0x0FFFFF; ]
		{ export *:1 loc; }

sfr_raw: loc is adr8 [ loc = 0x0FFF00 + adr8; ]
		{ export *:$(PTRSIZE) loc; }

#Imm16Swap: val is imm16_lo; imm16_hi [val=val|imm16_hi; val=val<<8; val=val|imm16_lo;] {export val;}

##########################################################################
#
# Instructions
#
##########################################################################

#:MOV
#TODO: The rest of MOV
#TODO: CD, CE, and CF moves
:MOV op1b_reg0," #"imm8	is op1b_hi=0x5 & op1b_b3!=0x1 & op1b_reg0; imm8 {
	op1b_reg0 = imm8;
}

:MOV A,op1b_reg0 		is op1b_hi=0x6 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	A = op1b_reg0;
}

:MOV op1b_reg0,A		is op1b_hi=0x7 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	op1b_reg0 = A;
}

:MOV op2b_sfr,A 		is op1b_byte=0x9E; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr & A {
	op2b_sfr = A;
}

:MOV op2b_sfr,"#"imm8 	is op1b_byte=0xCE; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr; imm8
{
	op2b_sfr = imm8;
}

:MOV sfr_raw,"#"imm8 	is op1b_byte=0xCE; sfr_raw & adr8_dupe<0xF0; imm8 
{
	*:1 sfr_raw = imm8;
}

:MOV [op1b_reg_dehl],A 	is op1b_hi=0x9 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A 
{
	write_byte(A, op1b_reg_dehl);
}

:MOV A,"["op1b_reg_dehl"]" is op1b_hi=0x8 
			& op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A
{
	read_byte(A, op1b_reg_dehl);
}

:MOV A,ES":["op1b_reg_dehl"]" is esmarker=0x11; 
			op1b_hi=0x8 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1
			& A & ES
{
	read_es_byte(A, op1b_reg_dehl);
}

:MOV ES,"#"imm8 		is op1b_byte=0x41; imm8 & ES
{
	ES = imm8;
}

:MOV A,imm16[BC] 		is op1b_byte=0x49; imm16 & A & BC {
	addr:2 = BC + imm16;
	read_byte(A, addr);
}

:MOV [op1b_reg_rp + adr8],"#"imm8 	is op1b_hi=0xC & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8; imm8
{
	local ptr:$(PTRSIZE) = 0x000000;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	#local tmp:2 = op1b_reg_rp;
	#tmp = tmp + sext(adr8:1);
	#ptr[0,16] = ptr[0,16] | tmp;
	*:1 ptr = imm8;
}

:MOV [op1b_reg_rp + adr8],A 		is op1b_hi=0x9 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	*:1 ptr = A;
}

:MOV A,[op1b_reg_rp + adr8] 		is op1b_hi=0x8 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	A = *:1 ptr;
}

:MOV A,sfr_raw			is op1b_byte=0x8E; sfr_raw & A 
{
	A = *:1 sfr_raw;
}

:MOV sfr_raw,A 			is op1b_byte=0x9E; sfr_raw & A 
{
	*:1 sfr_raw = A;
}

:MOV A,!addr16 			is op1b_byte=0x8F; addr16 & A
{
	A = *:1 addr16;
}

:MOV !addr16, A 		is op1b_byte=0x9F; addr16 & A
{
	*:1 addr16 = A;
}

#:XCH
#:ONEB
#:CLRB
#:MOVS

#:MOVW
#TODO: The rest of MOVW
#	we've done: movw imm16 into reg pair
# 				movw from regpair to AX
#				movw from AX to regpair
#				movw sfrp,#word
#				movw addr16,ax
#				movw ax,addr16
#				movw imm16[r], ax
#				movw ax, 1mm16[r]
#				movw rp, !imm16
#				movw [dehl], ax
#				movw ax, [dehl]
:MOVW op1b_2xreg," #"imm16 	is op1b_hi=0x3 & op1b_b3=0 & op1b_2xreg & op1b_b0=0; imm16{
	op1b_2xreg = imm16;
}

:MOVW AX,op1b_2xreg 		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & op1b_2xreg_dupe!=0x0 & AX {
	AX = op1b_2xreg;
}

:MOVW op1b_2xreg,AX		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=0 & op1b_2xreg_dupe!=0x0 & AX {
	op1b_2xreg = AX;
}

:MOVW op2b_sfrp,"#"imm16 is op1b_byte=0xCB; op2b_hi=0xF & op2b_b3=1 & op2b_b2=0 & op2b_sfrp; imm16
{
	op2b_sfrp=imm16;
}

:MOVW AX,!addr16		is op1b_byte=0xAF; addr16 & AX
{
	AX = *:2 addr16;
}

:MOVW !addr16,AX 		is op1b_byte=0xBF; addr16 & AX
{
	*:2 addr16 = AX;
}

:MOVW imm16[op1b_reg_4_5],AX 	is (op1b_byte=0x58 | op1b_byte=0x68) & op1b_reg_4_5;
							imm16 & AX 
{
	local ptr:$(PTRSIZE) = imm16 + zext(op1b_reg_4_5);
	*:2 ptr = AX;
}

:MOVW AX,imm16[op1b_reg_4_5] 	is (op1b_byte=0x59 | op1b_byte=0x69) & op1b_reg_4_5;
								imm16 & AX
{
	local ptr:$(PTRSIZE) = imm16 + zext(op1b_reg_4_5);
	AX = *:2 ptr;
}

:MOVW op1b_movw_rp,!addr16 		is op1b_b7=1 & op1b_b6=1 & op1b_movw_rp & op1b_lo=0xB & op1b_movw_rp_dupe!=0; addr16
{
	op1b_movw_rp = *:2 addr16;
}

:MOVW AX,[op1b_reg_dehl]		is op1b_hi=0xA & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	read_word(AX, op1b_reg_dehl);
}

:MOVW [op1b_reg_dehl],AX 		is op1b_hi=0xB & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	write_word(AX, op1b_reg_dehl);
}

#:XCHW

:ONEW op1b_reg_axbc 		is (op1b_byte=0xE6 | op1b_byte=0xE7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0001:2;
}

:CLRW op1b_reg_axbc 		is (op1b_byte=0xF6 | op1b_byte=0xF7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0000:2;
}

#:ADD
#TODO: All of add except ADD reg, reg
:ADD A,op2b_reg0 		is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	add_set_flags(A, op2b_reg0);
	A = A + op2b_reg0;
}

:ADD op2b_reg0, A			is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=0 & op2b_reg0 & A
{
	add_set_flags(op2b_reg0, A);
	op2b_reg0 = op2b_reg0 + A;
}

#:ADDC
#:SUB
#:SUBC

#:AND
#TODO: ~DONE
#DONE: and A, #imm8
:AND A,"#"imm8				is op1b_byte=0x5C; imm8 & A
{
	local tmp = A & imm8;
	$(Z_flag) = (tmp == 0);
	A = tmp;
}

#:OR
#:XOR

#:CMP
#TODO: Check if CMP operands are in wrong order in macro. ISA is unclear.
#TODO: Rest of CMP
# 		we've done 	cmp a, imm8
#				 	cmp a, reg
#					cmp reg, a
#					cmp !addr16, #byte
:CMP A,"#"imm8 	is op1b_byte=0x4C; imm8 & A {
	cmp8_set_flags(A, imm8);
}

:CMP A,op2b_reg0	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x1 & 
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(A, op2b_reg0);
}

:CMP op2b_reg0,A 	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x0 &
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(op2b_reg0, A);
}

:CMP !addr16,"#"imm8 	is op1b_byte=0x40; addr16; imm8{
	val:1 = 0x0;
	read_byte(val, addr16);
	cmp8_set_flags(val, imm8);
}

#:CMP0
#TODO: only done cmp0 a x b c 
:CMP0 op1b_reg0 		is op1b_hi=0xD & op1b_b3=0 & op1b_reg0 & op1b_reg0_dupe<4 
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (op1b_reg0 == 0x0);
}

#:CMPS

#:ADDW
#TODO: ADDW SP 
#TODO: All but 1 case of normal ADDW
:ADDW AX,"#"simm16 	is op1b_byte=0x04; simm16 & AX {
	addw_set_flags(AX, simm16);
	AX = AX + simm16;
}

#:SUBW

#:CMPW
#TODO: all not done
#DONE: cmpw ax, #imm16
#	   cmpw ax, rp
:CMPW AX,"#"imm16 	is op1b_byte=0x44; imm16 & AX{
	cmpw_set_flags(AX, imm16);
}

:CMPW AX,op1b_2xreg is op1b_hi=0x4 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & AX
{
	cmpw_set_flags(AX, op1b_2xreg);
}

:CMPW AX,[HL+adr8] 	is op1b_byte=0x61; op2b_byte=0x49; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, HL, adr8);
	local tmp = *:2 ptr;
	cmpw_set_flags(AX, tmp);
}

#:MULU
#:MULHU
#:MULH
#:DIVHU
#:DIVWU
#:MACHU
#:MACH

#:INC
#TODO: set CY and AC flags
#TODO: all of inc except register direct mode
#TODO: actually set flags

:INC op1b_reg0 		is op1b_hi=0x8 & op1b_b3=0 & op1b_reg0 {
	$(Z_flag) = (op1b_reg0 == 0xFF);
	op1b_reg0 = op1b_reg0 + 1;
}

#:DEC
#TODO: set CY and AC flags
#TODO: all of DEC except register mode
:DEC op1b_reg0 		is op1b_hi=0x9 & op1b_b3=0 & op1b_reg0 {
	$(Z_flag) = (op1b_reg0 == 0x1);
	op1b_reg0 = op1b_reg0-1;
}

#:INCW
#TODO: set CY and AC flags
#TODO: implemented thus far:
#				incw rp
:INCW op1b_2xreg 	is op1b_hi=0xA & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	$(Z_flag) = (op1b_2xreg == 0xFFFF);
	op1b_2xreg = op1b_2xreg+1;
}

#:DECW
#TODO: set CY and AC flags
#TODO: implemented thus far:
#				decw rp
:DECW op1b_2xreg 	is op1b_hi=0xB & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	$(Z_flag) = (op1b_2xreg == 0x0001);
	op1b_2xreg = op1b_2xreg-1;
}

:DECW [HL+adr8] 	is op1b_byte=0x61; op2b_byte=0x89; adr8 & HL
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, HL, adr8);
	local tmp = *:2 ptr;
	*:2 ptr = tmp - 1;
}
#:SHR

:SHRW AX,op2b_hi_val	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xE & op2b_hi!=0x0 & AX {
	sr_set_flags16(AX, op2b_hi_val);
	AX = AX >> op2b_hi_val;
}

#:SHL
#:SHLW

:SAR A,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xB & op2b_hi<0x8 & A {
	sr_set_flags8(A, op2b_hi_val);
	A = A s>> op2b_hi_val;
} 


#:SARW
#:ROR
#:ROL
#:RORC
#:ROLC
#:ROLWC

#:MOV1
#TODO: 	all mov1 except mov1 CY, A.x
#						mov1 sfr.x, CY
#						mov1 CY, [HL].x
#						mov1 [HL].x, CY

:MOV1 op3b_sfr"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=0x0 & op2b_bit_sel & op2b_lo=0x9; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	local tmp = op3b_sfr;
	local mask = (0xFF & (~(0x1)<<op2b_bit_sel));
	tmp = tmp & mask;
	op3b_sfr = tmp|($(CY_flag)<<op2b_bit_sel);
}

:MOV1 "CY,"A"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xC & A
{
	$(CY_flag) = ((A>>op2b_bit_sel)&0x1);
}

#TODO: Ghidra thinks the bit select value is the offset. needs to be fixed.
:MOV1 "CY,"[HL]"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4 & HL 
{
	local tmp:1 = 0x0;
	read_byte(tmp, HL);
	$(CY_flag) = ((tmp>>op2b_bit_sel)&0x1);
}

:MOV1 [HL]"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x1 & HL
{
	local hl_dupe:1 = 0x0;
	read_byte(hl_dupe, HL);
	local mask = ~(0x1 << op2b_bit_sel);
	hl_dupe = hl_dupe & mask;
	hl_dupe = hl_dupe|($(CY_flag)<<op2b_bit_sel);
	write_byte(hl_dupe, HL);
}
#:AND1
#:OR1
#:XOR1

#:SET1
#TODO: all set1 not in done list
#TODO: reuse bit_set_to macro in other spots
#Done: 				set1 !addr16.x

:SET1 !addr16"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0; addr16
{
	local tmp:1 = 0;
	tmp = *:1 addr16;
	bit_set_to(tmp, op2b_bit_sel, 1);
	*:1 addr16 = tmp;
}

#:CLR1

#:CALL
#TODO: all calls except addr16 type
#						addr20 type
:CALL !jaddr16 		is op1b_byte=0xFD; jaddr16 
{
	local nextpc:3 = inst_next;
	local nextpc_lo:2 = nextpc[0,16];
	local nextpc_hi:2 = 0x0:2;
	nextpc_hi[0,4] = nextpc[16,4];
	push_word(nextpc_hi, SP);
	push_word(nextpc_lo, SP);
	call jaddr16;
}

:CALL !!jaddr20 	is op1b_byte=0xFC; jaddr20
{
	local nextpc:3 = inst_next;
	local nextpc_lo:2 = nextpc[0,16];
	local nextpc_hi:2 = 0x0:2;
	nextpc_hi[0,4] = nextpc[16,4];
	push_word(nextpc_hi, SP);
	push_word(nextpc_lo, SP);
	call jaddr20;
}

#:CALLT
#:BRK

:RET 				is op1b_byte=0xD7 
{
	ptr:$(PTRSIZE) = 0x0:3;
	local retaddr_lo:2 = 0x0:2;
	local retaddr_hi:2 = 0x0:2;
	pop_word(retaddr_lo, SP);
	pop_word(retaddr_hi, SP);
	ptr[0,16] = retaddr_lo;
	ptr[16,4] = retaddr_hi[0,4];
	return [ptr];
}

#:RETI
#:RETB

#:PUSH
#TODO: need PUSH PSW
#TODO: resolve 1-byte store ops
:PUSH op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=1 {
	SP = SP - 2;
	write_stack_word(op1b_2xreg, SP);
}

#:POP
#TODO: need POP PSW
#TODO: resolve 1-byte read ops
:POP op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=0 {
	read_stack_word(op1b_2xreg, SP);
	SP = SP + 2;
}

#:MOVW
#:ADDW
#:SUBW

#:BR
#TODO: All of BR except indirect address
:BR "$"RelAddr8 		is op1b_byte=0xEF; RelAddr8 {
	goto RelAddr8;
}

:BC "$"RelAddr8			is op1b_byte=0xDC; RelAddr8 {
	if ($(CY_flag)) goto RelAddr8;
}

:BNC "$"RelAddr8 		is op1b_byte=0xDE; RelAddr8 {
	if (!$(CY_flag)) goto RelAddr8;
}

:BZ "$"RelAddr8 		is op1b_byte=0xDD; RelAddr8 {
	if ($(Z_flag)) goto RelAddr8;
}

:BNZ "$"RelAddr8 		is op1b_byte=0xDF; RelAddr8 {
	if (!$(Z_flag)) goto RelAddr8;
}

:BH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xC3; RelAddr8 {
	if (!($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

:BNH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xD3; RelAddr8 {
	if (($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

:BT A"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x3; RelAddr8 & A
{
	local bit = 0x0;
	bit_get(A, op2b_bit_sel, bit);
	if bit goto RelAddr8;
}

#:BF
#:BTCLR

:SKC 					is op1b_byte=0x61; op2b_byte=0xC8
{
	if $(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNC					is op1b_byte=0x61; op2b_byte=0xD8
{
	if !$(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKZ 					is op1b_byte=0x61; op2b_byte=0xE8 
{
	if  $(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNZ 					is op1b_byte=0x61; op2b_byte=0xF8 
{
	if !$(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

#:SKH
#:SKNH

:SEL "RB"op2b_reg_rbsel			is op1b_byte=0x61; op2b_hi2=0x3 & op2b_reg_rbsel & op2b_lo=0xF
{
	$(RBS1_flag) = ((op2b_reg_rbsel>>1)&0x1);
	$(RBS0_flag) = op2b_reg_rbsel&0x1;
}

:NOP					is op1b_byte=0x00 {}

#:EI
#:DI
#:HALT
#:STOP
#:PREFIX
