##########################################################################
#
# Attempt at implementing the RL78
# 16-bit MCU ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

define endian=little;
define alignment=1;

@define PTRSIZE "3"

define space ram 		type=ram_space		size=$(PTRSIZE) wordsize=1	default;
define space stackarea 	type=ram_space 		size=2;
define space register 	type=register_space size=1;

#TODO: mess with a virtual stack register of some sort using context registers?
#TODO: figure out how to cleanly implement register banks
#TODO: refactor bunk register access logic, using pg. 3 of the data sheet as a reference

#general purpose registers:
define register offset= 0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3]; 	# 8-bit-mode bank3
define register offset= 0x00 size=2 [AX3   BC3   DE3   HL3];	#16-bit-mode bank3
define register offset= 0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2]; 	# 8-bit-mode bank2
define register offset= 0x08 size=2 [AX2   BC2   DE2   HL2];	#16-bit-mode bank2
define register offset= 0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1]; 	# 8-bit-mode bank1
define register offset= 0x10 size=2 [AX1   BC1   DE1   HL1];	#16-bit-mode bank1
define register offset= 0x18 size=1 [X  A  C  B  E  D  L  H]; 	# 8-bit-mode bank0
define register offset= 0x18 size=2 [AX    BC    DE    HL];	 	#16-bit-mode bank0
define register offset= 0x20 size=1 [RB0 RB1 RB2 RB3];			#dummy args for register banks

#special purpose registers
define register offset=0x40 size=3 [PC]; #I Think this is right??? they don't specify
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];

#TODO: change to using bitranges, once its fixed
#define bitrange IE=PSW[7,1] Z=PSW[6,1] RBS1=PSW[5,1] AC=PSW[4,1] RBS0=PSW[3,1] 
#				ISP1=PSW[2,1] ISP0=PSW[1,1] CY=PSW[0,1];

#Flag bits
#Macros? I think? to make accessing the bits in the PSW easier
#TODO: convert elements of the PSW to use the bitrange feature
@define IE_flag 	"PSW[7,1]"	# Interrupt Enable (IE)
@define Z_flag  	"PSW[6,1]" 	# Zero Flag (Z)
@define RBS1_flag   "PSW[5,1]"	# Register Bank Select Hi-Bit (RBS1)
@define AC_flag 	"PSW[4,1]"  # Auxiliary Carry Flag (AC)
@define RBS0_flag	"PSW[3,1]" 	# Register Bank Select Lo-Bit (RBS0)
@define ISP1_flag 	"PSW[2,1]" 	# In-service priority flag Hi-Bit (ISP1)
@define ISP0_flag 	"PSW[1,1]"  # In-service priority flag Lo-Bit (ISP0)
@define CY_flag 	"PSW[0,1]"  # Carry flag (CY)

#########################################################################
#
# Pseudocode ops
#
#########################################################################

#define pcodeop skip;
define pcodeop todo;

#########################################################################
#
# Operand data types
#
# FYI: You can think of sleigh tokens as both bitfields and parser 
# 	   directives. Basically, a token is any element that is a potential
# 	   sub-field you may want to parse out of an instruction, and the 
# 	   attach keyword is used to turn those parsed fields into
#	   elements of a register map cleanly.
#
#########################################################################

define token op1b (8) 
	op1b_byte = (0,7)

	op1b_hi = (4,7)
	op1b_lo = (0,3)
	op1b_lo3 = (0,2)

	op1b_reg0 = (0,2)
	op1b_reg_4_5 = (4,5)
	op1b_reg0_dupe = (0,2)
	op1b_2xreg = (1,2)
	op1b_2xreg_dupe = (1,2) #duplicate to check val
	op1b_reg_dehl = (1,1) #special namespace for mov operations
					   #which are limited to DE and HL r/w.
					   #This includes all mem load/store ops.
	op1b_reg_axbc = (0,0) #special namespace for clrw & co, only uses ax/bc
	op1b_movw_rp = (4,5)
	op1b_movw_rp_dupe = (4,5)
	op1b_reg_rp = (1,2)
	op1b_reg_rp_dupe = (1,2)
	op1b_movr = (4,5)
	op1b_movr_dupe = (4,5)

	op1b_b7 = (7,7)
	op1b_b6 = (6,6)
	op1b_b5 = (5,5)
	op1b_b4 = (4,4)
	op1b_b3 = (3,3)
	op1b_b2 = (2,2)
	op1b_b1 = (1,1)
	op1b_b0 = (0,0)
;

define token op2b (8)
	op2b_byte = (0,7)
	op2b_hi = (4,7)
	op2b_hi_val = (4,7) #duplicate to check val without causing issues
	op2b_lo = (0,3)
	op2b_sfr = (0,2)
	op2b_sfrp = (0,1)

	op2b_b7 = (7,7)
	op2b_b3 = (3,3)
	op2b_b2 = (2,2)

	op2b_reg0 = (0,2)
	op2b_reg0_dupe = (0,2)
	op2b_reg_rbsel = (4,5)

	op2b_hi2 = (6,7)
	op2b_bit_sel = (4,6)
;

define token calltref (8)
	calltref_b7 = (7,7)
	calltref_hi = (4,6)
	calltref_b3 = (3,3)
	calltref_b2 = (2,2)
	calltref_lo = (0,1)
;

define token op3b (8)	
	op3b_byte = (0,7)
	op3b_sfr = (0,2)
	op3b_hi = (4,7)
	op3b_lo = (0,3)
	op3b_b3 = (3,3)
;

define token esbyte (8)
	esmarker = (0,7)
;

define token data8 (8)
	uadr8 = (0,7)
	adr8_dupe = (0,7)
	adr8 = (0,7) signed
	imm8 = (0,7)
	simm8 = (0,7) signed
;

define token data16 (16)
	imm16 = (0,15)
	imm16_lo = (0,7)
	imm16_hi = (8,15)
	simm16 = (0,15) signed
;

define token data24 (24)
	imm24 = (0,23)
;

attach variables [op1b_reg0 op2b_reg0] 	[X A C B E D L H];
attach variables [op1b_2xreg]			[AX BC DE HL];
attach variables [op2b_sfr op3b_sfr]	[SPL SPH PSW _ CS ES PMC MEM];
attach variables [op1b_reg_dehl]		[DE HL];
attach variables [op1b_reg_axbc]		[AX BC];
attach variables [op2b_sfrp]			[SP      _     _     _      ];
attach variables [op1b_reg_4_5]			[_ B C _];
attach variables [op1b_reg_rp]			[_ DE HL _];
attach variables [op1b_movw_rp]			[_ BC DE HL];
attach variables [op1b_movr]			[_ X B C];

##########################################################################
#
# Macros
#
##########################################################################

#macro push16(val16) {
#	SP = SP - 2;
#	ptr:$(PTRSIZE) = SP;
#	*:2 ptr = val16; 
#}



macro addw_set_flags(val1, val2){
	local tmp1:2;
	local tmp2:2;
	tmp1 = (val1>>15)&0x1;
	tmp2 = (val2>>15)&0x1;
	$(CY_flag) = tmp1[0,1] & tmp2[0,1];
	$(Z_flag) = (val1 == (-val2));
	$(AC_flag) = 0;
}

macro add_set_flags(val1, val2){
	$(CY_flag) = ((val1>>7)&0x1) & ((val2>>7)&0x1);
	$(Z_flag)  = (val1 == (-val2));
	local tmp:1 = 0x0;
	tmp = val1[0,3] + val2[0,3];
	tmp = (tmp >> 3) & 0x1;
	$(AC_flag) = tmp;
}

macro sr_set_flags16(reg, imm){
	local tmp:2 = (reg >> imm) & 0x1:2;
	local tmp2:1 = tmp[0,7];
	$(CY_flag) = tmp2;
}

macro sr_set_flags8(reg, imm){
	local tmp:1 = (reg >> imm) & 0x1:1;
	$(CY_flag) = tmp;
}

macro read_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_stack_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_es_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = ptr[0, 16] | addr;
	ptr[16, 4] = ptr[16, 4] | ES[0, 4];
	dst = *:1 ptr;
}

macro write_byte(src, addr){
	ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0,16] = ptr[0,16] | addr;
	*:1 ptr = src;
}

macro write_stack_byte(src, addr){
	local ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0, 16] = addr[0,16];
	*:1 ptr = src;
}

#macro write_es_byte(src, addr){}

#TODO: check if base for mem reads is 0xF or 0x0, 
#		datasheet and ODA seem to disagree. 
macro read_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro write_word(src, addr){
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro write_stack_word(src, addr){
	#TODO: replace all write_stack_word uses with push_word uses
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro push(src){
	SP = SP - 2;
	*[stackarea]:2 SP = src;
}

macro pop(dst){
	dst = *[stackarea]:2 SP;
	SP = SP + 2;
}

macro pushpc(pc, inter){
	SP = SP - 3;
	*[stackarea]:3 SP = pc:3;
	SP = SP - 1;
	*[stackarea]:1 SP = inter:1;
}

macro poppc(pc, inter){
	inter = *[stackarea]:1 SP;
	SP = SP + 1;
	pc = *[stackarea]:3 SP;
	SP = SP + 3;
}

macro push_word(src){
	SP = SP - 2;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = SP;
	ptr[16, 4] = 0xF;
	*:2 ptr = SP;
}


macro read_stack_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr;
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro pop_word(dst){
	#TODO: replace all read_stack_word uses with pop_word
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = SP;
	ptr[16, 4] = 0xF;
	dst = *:2 ptr;
	SP = SP + 2;
}

macro cmp8_set_flags(arg1, arg2){
	$(Z_flag) = ((arg2 - arg1) == 0);
	$(CY_flag) = ((arg2 & 0x7f) < (arg1 & 0x7f));
	$(AC_flag) = ((arg2 & 0x07) < (arg1 & 0x07));
}

macro cmpw_set_flags(arg1, arg2){
	$(Z_flag) = (arg2 == arg1);
}

macro subw_set_flags(dst, src){
	$(AC_flag) = 0;
	$(Z_flag) = (dst == src);
	$(CY_flag) = (dst < src);
}

macro bit_set_to(val, bit_index, set_to){
	local mask = ~(0x1 << bit_index);
	val = val & mask;
	val = val|(set_to<<bit_index);
}

macro bit_get(val, bit_index, dst){
	local tmp = (val>>bit_index);
	dst = (tmp & 0x1);
}

#TODO: can I turn the 2 macro's below into 1? don't see why not?
macro reg_stackarea_offset8(saptr, ptr_reg, adr){
	saptr = 0x0F0000;
	local tmp:3 = saptr | zext(ptr_reg);
	saptr = tmp + adr;
}

macro reg_stackarea_offset16(saptr, ptr_reg, adr){
	saptr = 0x0F0000;
	local tmp:3 = saptr | zext(ptr_reg);
	saptr = tmp + adr;
}

#TODO: fix up all the mangled references
#		This was based off the z80 slaspec, but they screwed up the handling real bad.
#		Export *: doesn't export a pointer, it exports a reference which ghiddra converts
#		into a pointer down the road, and the z80 guys didnt seem to get that. add
#		TODO: replace all addr16 with add16_1x or add16_2x
RelAddr8: loc  is simm8  [ loc = inst_next + simm8; ]        
		{ export *:$(PTRSIZE) loc; }

addr16:   loc is imm16 [ loc = 0xf0000 + imm16;]	
		{ export *:$(PTRSIZE) loc; }

addr16_1x:   loc is imm16 [ loc = 0xf0000 + imm16;]	
		{ export *:1 loc; }

addr16_2x: 	 loc is imm16 [ loc = 0xf0000 + imm16;]
		{ export *:2 loc;}

jaddr16:  loc is imm16 [ loc = 0x00000 | imm16;]
		{ export *:1 loc; }

jaddr20: loc is imm24 [ loc = imm24&0x0FFFFF; ]
		{ export *:1 loc; }

callt_addr: ["vector_table:"adr] is calltref_b7=1 & calltref_hi & calltref_b3=0 & calltref_b2=1 & calltref_lo
[
	adr = 0x80 | ((calltref_hi<<1) | (calltref_lo<<4));
]
{
	local newadr:3 = 0x0:3 | zext(adr:1);
	local table_deref:2 = *:2 newadr;
	local jmptarget:$(PTRSIZE) = zext(table_deref);
	export *:1 jmptarget;
}

#also called saddr in data sheet? wait no i think i was wrong -- need to fix this
#TODO: separate sfr and sadr calls
#TODO: replace messy sfr/sfrp invocations
sfr: op2b_sfr is op2b_hi=0xF & op2b_b3=1 & op2b_sfr { export op2b_sfr; }

sfrp: op2b_sfrp is op2b_hi=0xF & op2b_b3=1 & op2b_b2=0 & op2b_sfrp { export op2b_sfrp; }

sfr_raw1: "sfr:"loc is uadr8 [loc = 0x0FFF00 + uadr8; ]
		{  export *[ram]:1 loc; }

sfr_raw2: "sfr:"loc is uadr8 [ loc = 0x0FFF00 + uadr8; ]
		{ export *[ram]:2 loc; }

saddr: 	loc is uadr8 [ loc = 0xFFF00 + uadr8; ]
		{ export *[ram]:1 loc; }

saddrp: loc is uadr8 [ loc = 0xFFF00 + uadr8; ]
		{ export *[ram]:2 loc; }

#TODO: replace all [HL+x] calls with hl_offset
#TODO: figure out how to clean these up so that ghidra is less weird about offsets during disasm.
hl_offset: [HL+adr8] is adr8 & HL 
		{ local tmp:3 = 0xF0000:3 + zext(HL:2); 
		  local loc:3 = tmp + zext(adr8:1);
		  export *[ram]:1 loc; }

hl_offset_word: [HL+adr8] is adr8 & HL 
		{ local tmp:3 = 0xF0000:3 + zext(HL:2); 
		  local loc:3 = tmp + zext(adr8:1);
		  export *[ram]:2 loc; }

b_offset_byte: imm16[B] is imm16 & B
		{ local tmp:3 = 0xF0000:3 + zext(BC:2);
		  local loc:3 = tmp + zext(imm16:2);
		  export *[ram]:1 loc;
		}

bc_offset_word: imm16[BC] is imm16 & BC
		{ local tmp:3 = 0xF0000:3 + zext(BC:2);
		  local loc:3 = tmp + zext(imm16:2);
		  export *[ram]:2 loc;
		}

sp_offset_byte: [SP+adr8] is adr8 & SP
		{ local loc:2 = zext(adr8:1) + SP;
		  export *[stackarea]:1 loc; 
		}

#Imm16Swap: val is imm16_lo; imm16_hi [val=val|imm16_hi; val=val<<8; val=val|imm16_lo;] {export val;}

##########################################################################
#
# Instructions
#
##########################################################################

#:MOV
#TODO: The rest of MOV
:MOV op1b_reg0," #"imm8	is op1b_hi=0x5 & op1b_b3!=0x1 & op1b_reg0; imm8 {
	op1b_reg0 = imm8;
}

:MOV A,op1b_reg0 		is op1b_hi=0x6 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	A = op1b_reg0;
}

:MOV op1b_reg0,A		is op1b_hi=0x7 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	op1b_reg0 = A;
}

:MOV op2b_sfr,A 		is op1b_byte=0x9E; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr & A {
	op2b_sfr = A;
}

:MOV op2b_sfr,"#"imm8 	is op1b_byte=0xCE; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr; imm8
{
	op2b_sfr = imm8;
}

:MOV sfr_raw1,"#"imm8 	is op1b_byte=0xCE; sfr_raw1 & adr8_dupe<0xF0; imm8 
{
	sfr_raw1 = imm8;
}

:MOV sfr_raw1,"#"imm8 	is op1b_byte=0xCD; sfr_raw1; imm8 
{
	sfr_raw1 = imm8;
}


:MOV [op1b_reg_dehl],A 	is op1b_hi=0x9 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A 
{
	write_byte(A, op1b_reg_dehl);
}

:MOV A,"["op1b_reg_dehl"]" is op1b_hi=0x8 
			& op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A
{
	read_byte(A, op1b_reg_dehl);
}

:MOV A,ES":["op1b_reg_dehl"]" is esmarker=0x11; 
			op1b_hi=0x8 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1
			& A & ES
{
	read_es_byte(A, op1b_reg_dehl);
}

:MOV ES,"#"imm8 		is op1b_byte=0x41; imm8 & ES
{
	ES = imm8;
}

:MOV A,imm16[BC] 		is op1b_byte=0x49; imm16 & A & BC {
	addr:2 = BC + imm16;
	read_byte(A, addr);
}

:MOV [op1b_reg_rp+adr8],"#"imm8 	is op1b_hi=0xC & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8; imm8
{
	local ptr:$(PTRSIZE) = 0x000000;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	*:1 ptr = imm8;
}

:MOV [op1b_reg_rp+adr8],A 		is op1b_hi=0x9 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	*:1 ptr = A;
}

:MOV A,[op1b_reg_rp+adr8] 		is op1b_hi=0x8 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0 & (op1b_reg_rp_dupe=1 | op1b_reg_rp_dupe=2); adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	A = *:1 ptr;
}

:MOV A,sfr_raw1			is op1b_byte=0x8E; sfr_raw1 & A 
{
	A = sfr_raw1;
}

:MOV sfr_raw1,A 			is op1b_byte=0x9E; sfr_raw1 & A 
{
	sfr_raw1 = A;
}

:MOV A,!addr16_1x			is op1b_byte=0x8F; addr16_1x & A
{
	A = addr16_1x;
}

:MOV !addr16, A 		is op1b_byte=0x9F; addr16 & A
{
	*:1 addr16 = A;
}

:MOV !addr16_1x,"#"imm8 	is op1b_byte=0xCF; addr16_1x; imm8
{
	addr16_1x = imm8;
}

:MOV op1b_movr,!addr16_1x 	is op1b_b7=1 & op1b_b6=1 & op1b_movr & op1b_lo=0x9 & 
					op1b_movr_dupe!=0; addr16_1x
{
	op1b_movr = addr16_1x;
}

:MOV op1b_movr,sfr_raw1 	is op1b_b7=1 & op1b_b6=1 & op1b_movr & op1b_lo=0x8 &
					op1b_movr_dupe!=0; sfr_raw1
{
	op1b_movr = sfr_raw1;
}

:MOV A,saddr  				is op1b_byte=0x8D; saddr & A
{
	A=saddr;
}

:MOV saddr,A 				is op1b_byte=0x9D; saddr & A
{
	saddr=A;
}

:MOV A,b_offset_byte			is op1b_byte=0x09; b_offset_byte & A
{
	A = b_offset_byte;
}

:MOV b_offset_byte,A 			is op1b_byte=0x18; b_offset_byte & A
{
	b_offset_byte = A;
}

:MOV sp_offset_byte,A 			is op1b_byte=0x98; sp_offset_byte & A
{
	sp_offset_byte = A;
}

:MOV A,sp_offset_byte 			is op1b_byte=0x88; sp_offset_byte & A
{
	A=sp_offset_byte;
}

#:TODO: *
#:XCH
# 		XCH A, X
macro inst_xch(dst, src){
	local tmp = dst;
	dst = src;
	src = tmp;
}

:XCH A, X 					is op1b_byte=0x08 & A & X
{
	inst_xch(A, X);
}

#:ONEB
#TODO: etc
#DONE: ONEB !addr16
#		oneb, axbc
:ONEB !addr16_1x 			is op1b_byte=0xE5; addr16_1x
{
	addr16_1x = 0x1:1;
}

:ONEB op1b_reg0		is op1b_hi=0xE & op1b_b3=0 & op1b_reg0 & op1b_b2=0
{
	op1b_reg0 = 0x1:1;
}

#:CLRB
#TODO: CLRB ES:!addr16
:CLRB !addr16_1x 		is op1b_byte=0xF5; addr16_1x
{
	addr16_1x = 0x00;
}

:CLRB saddr 			is op1b_byte=0xF4; saddr
{
	saddr = 0x00;
}


:CLRB op1b_reg_axbc 	is op1b_hi=0xF & op1b_b3=0 & op1b_b2=0 & op1b_reg_axbc
{
	op1b_reg_axbc = 0x00;
}

#:MOVS

#:MOVW
#TODO: The rest of MOVW
#	we've done: movw imm16 into reg pair
# 				movw from regpair to AX
#				movw from AX to regpair
#				movw sfrp,#word
#				movw addr16,ax
#				movw ax,addr16
#				movw imm16[r], ax
#				movw ax, 1mm16[r]
#				movw rp, !imm16
#				movw [dehl], ax
#				movw ax, [dehl]
#				movw sfrp, #word
#				movw AX, [hl+byte]
#				movw [hl+byte], AX
#				movw sfrp, AX
#				movw AX, sfrp
#				movw ax, saddrp
#				movw saddrp, AX
#				movw bc/de/hl, saddrp
#				movw imm16[rp], ax
#				movw ax, imm16[rp]
:MOVW op1b_2xreg," #"imm16 	is op1b_hi=0x3 & op1b_b3=0 & op1b_2xreg & op1b_b0=0; imm16{
	op1b_2xreg = imm16;
}

:MOVW AX,op1b_2xreg 		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & op1b_2xreg_dupe!=0x0 & AX {
	AX = op1b_2xreg;
}

:MOVW op1b_2xreg,AX		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=0 & op1b_2xreg_dupe!=0x0 & AX {
	op1b_2xreg = AX;
}

:MOVW op2b_sfrp,"#"imm16 is op1b_byte=0xCB; op2b_hi=0xF & op2b_b3=1 & op2b_b2=0 & op2b_sfrp; imm16
{
	op2b_sfrp=imm16;
}

:MOVW AX,!addr16		is op1b_byte=0xAF; addr16 & AX
{
	AX = *:2 addr16;
}

:MOVW !addr16_2x,AX 		is op1b_byte=0xBF; addr16_2x & AX
{
	addr16_2x = AX;
}

:MOVW imm16[op1b_reg_4_5],AX 	is (op1b_byte=0x58 | op1b_byte=0x68) & op1b_reg_4_5;
							imm16 & AX 
{
	local ptr:$(PTRSIZE) = imm16 + zext(op1b_reg_4_5);
	*:2 ptr = AX;
}

:MOVW AX,imm16[op1b_reg_4_5] 	is (op1b_byte=0x59 | op1b_byte=0x69) & op1b_reg_4_5;
								imm16 & AX
{
	local ptr:$(PTRSIZE) = imm16 + zext(op1b_reg_4_5);
	AX = *:2 ptr;
}

:MOVW op1b_movw_rp,!addr16 		is op1b_b7=1 & op1b_b6=1 & op1b_movw_rp & op1b_lo=0xB & op1b_movw_rp_dupe!=0; addr16
{
	op1b_movw_rp = *:2 addr16;
}

:MOVW AX,[op1b_reg_dehl]		is op1b_hi=0xA & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	read_word(AX, op1b_reg_dehl);
}

:MOVW [op1b_reg_dehl],AX 		is op1b_hi=0xB & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	write_word(AX, op1b_reg_dehl);
}

:MOVW sfr_raw2,"#"imm16 		is op1b_byte=0xCB; sfr_raw2; imm16
{
	sfr_raw2 = imm16;
}

:MOVW AX,[HL+adr8]				is op1b_byte=0xAC; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, HL, adr8);
	AX = *:2 ptr;
}

:MOVW [HL+adr8],AX 				is op1b_byte=0xBC; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, HL, adr8);
	*:2 ptr = AX;
}

:MOVW AX,[DE+adr8] 				is op1b_byte=0xAA; adr8 & AX & DE
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, DE, adr8);
	AX = *:2 ptr;
}

:MOVW [DE+adr8],AX 				is op1b_byte=0xBA; adr8 & AX & DE
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, DE, adr8);
	*:2 ptr = AX;
}

:MOVW sfrp,AX 				is op1b_byte=0xBE; sfrp & AX
{
	sfrp = AX;
}

:MOVW sfr_raw2,AX 			is op1b_byte=0xBE; sfr_raw2 & AX
{
	sfr_raw2 = AX;
}

:MOVW AX,sfrp 				is op1b_byte=0xAE; sfrp & AX
{
	AX = sfrp;
}

:MOVW AX,sfr_raw2 			is op1b_byte=0xAE; sfr_raw2 & AX
{
	AX = sfr_raw2;
}

:MOVW saddrp,AX 			is op1b_byte=0xBD; saddrp & AX
{
	saddrp = AX;
}

:MOVW AX,saddrp 			is op1b_byte=0xAD; saddrp & AX
{
	AX = saddrp;
}

:MOVW op1b_movw_rp,saddrp			is op1b_b7=1 & op1b_b6=1 & op1b_movw_rp & op1b_lo=0xA; saddrp
{
	op1b_movw_rp = saddrp;
}

:MOVW AX,bc_offset_word 			is op1b_byte=0x79; bc_offset_word & AX
{
	AX = bc_offset_word;
}

:MOVW bc_offset_word,AX 			is op1b_byte=0x78; bc_offset_word & AX
{
	bc_offset_word = AX;
}


:XCHW AX,op1b_2xreg 				is op1b_hi=0x3 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & AX
{
	local tmp:2 = AX;
	AX = op1b_2xreg;
	op1b_2xreg=tmp;
}

:ONEW op1b_reg_axbc 		is (op1b_byte=0xE6 | op1b_byte=0xE7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0001:2;
}

:CLRW op1b_reg_axbc 		is (op1b_byte=0xF6 | op1b_byte=0xF7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0000:2;
}

#:ADD
#TODO: All of add except ADD reg, reg
# 						ADD A, imm8
#						ADD A, [hl+adr8]
:ADD A,op2b_reg0 		is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	add_set_flags(A, op2b_reg0);
	A = A + op2b_reg0;
}

:ADD op2b_reg0, A			is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=0 & op2b_reg0 & A
{
	add_set_flags(op2b_reg0, A);
	op2b_reg0 = op2b_reg0 + A;
}

:ADD A,"#"imm8 				is op1b_byte=0x0C; imm8 & A
{
	add_set_flags(A, imm8:1);
	A = A + imm8;
}

:ADD A,hl_offset 			is op1b_byte=0x0E; hl_offset & A
{
	add_set_flags(A, hl_offset);
	A = A + hl_offset;
}

#:ADDC
#:SUB
#:SUBC

#:AND
#TODO: ~DONE
#DONE: and A, #imm8
#		and A, saddr
:AND A,"#"imm8				is op1b_byte=0x5C; imm8 & A
{
	local tmp = A & imm8;
	$(Z_flag) = (tmp == 0);
	A = tmp;
}

:AND A,sfr_raw1 			is op1b_byte=0x5B; sfr_raw1 & A 
{
	local tmp = A & sfr_raw1;
	$(Z_flag) = (tmp == 0);
	A = tmp;
}

#:OR
#TODO: more macros for instructions in this style. way cleaner. 
#TODO: add documentation of instructions at each instruction
#TODO: *
#DONE: or saddr, #byte
#		or A, #byte
# 		or A, reg
# 		or reg, A
macro inst_or(dst, src){
	local tmp = 0x0;
	tmp = dst | src;
	$(Z_flag) = (tmp == 0);
	dst = tmp;
}

:OR saddr,"#"imm8 			is op1b_byte=0x6A; saddr; imm8
{
	inst_or(saddr, imm8);
}

:OR A,"#"imm8 				is op1b_byte=0x6C; imm8 & A
{
	inst_or(A, imm8);
}

:OR A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x6 & op2b_b3=1 & op2b_reg0 & A
{
	inst_or(A,op2b_reg0);
}

:OR op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x6 & op2b_b3=0 & op2b_reg0 & A
{
	inst_or(op2b_reg0,A);
}
#:XOR

#:CMP
#TODO: Check if CMP operands are in wrong order in macro. ISA is unclear.
#TODO: Rest of CMP
# 		we've done 	cmp a, imm8
#				 	cmp a, reg
#					cmp reg, a
#					cmp !addr16, #byte
#					cmp a, saddr
#					cmp saddr, imm8
#					cmp A,[hl+byte]
:CMP A,"#"imm8 	is op1b_byte=0x4C; imm8 & A {
	cmp8_set_flags(A, imm8);
}

:CMP A,op2b_reg0	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x1 & 
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(A, op2b_reg0);
}

:CMP op2b_reg0,A 	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x0 &
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(op2b_reg0, A);
}

:CMP !addr16,"#"imm8 	is op1b_byte=0x40; addr16; imm8{
	val:1 = 0x0;
	read_byte(val, addr16);
	cmp8_set_flags(val, imm8);
}

:CMP A, saddr 			is op1b_byte=0x4B; saddr & A
{
	cmp8_set_flags(A, saddr);
}

:CMP saddr,"#"imm8 		is op1b_byte=0x4A; saddr; imm8
{
	cmp8_set_flags(saddr, imm8);
}

:CMP A,hl_offset 		is op1b_byte=0x4E; hl_offset & A
{
	cmp8_set_flags(A, hl_offset);
}




:CMP0 op1b_reg0 		is op1b_hi=0xD & op1b_b3=0 & op1b_reg0 & op1b_reg0_dupe<4 
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (op1b_reg0 == 0x0);
}

:CMP0 !addr16_1x 			is op1b_byte=0xD5; addr16_1x
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (addr16_1x == 0x0);
}

:CMP0 saddr 			is op1b_byte=0xD4; saddr
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (saddr == 0x0);
}

:CMP0 ES:!addr16_1x 	is op1b_byte=0x11; op2b_byte=0xD5; addr16_1x & ES
{
	todo();
}


#:CMPS

#:ADDW
#TODO: etc
#DONE: addw AX, simm16
#		addw AX, addr16
#		addw SP, #byte
# 		addw AX, rp
:ADDW AX,"#"simm16 	is op1b_byte=0x04; simm16 & AX 
{
	addw_set_flags(AX, simm16);
	AX = AX + simm16;
}

:ADDW AX,!addr16_2x	is op1b_byte=0x02; addr16_2x & AX
{
	addw_set_flags(AX, addr16_2x);
	AX = AX + addr16_2x;
}

:ADDW SP,"#"imm8 	is op1b_byte=0x10; imm8 & SP 
{
	SP = SP + zext(imm8:1);
}

:ADDW AX,op1b_2xreg is op1b_hi=0x0 & op1b_2xreg & op1b_b0=1 & AX
{
	addw_set_flags(AX, op1b_2xreg);
	AX = AX + op1b_2xreg;
}

#:SUBW
#TODO: etc
#DONE: subw AX, #imm16
#		SUBW AX, rp
#		SUBW SP, #imm8
:SUBW AX,"#"imm16 	is op1b_byte=0x24; imm16 & AX
{
	subw_set_flags(AX,imm16);
	AX = AX - imm16;
}

:SUBW AX, op1b_reg_rp 	is op1b_hi=0x2 & op1b_b3=0 & op1b_reg_rp & op1b_b0=1 & op1b_reg_rp_dupe!=0 & AX
{
	subw_set_flags(AX,op1b_reg_rp);
	AX = AX - op1b_reg_rp;
}

:SUBW SP,"#"imm8 		is op1b_byte=0x20; imm8 & SP
{
	local tmp:2 = sext(imm8:1);
	subw_set_flags(SP,tmp);
	SP = SP - tmp;
}

#:CMPW
#TODO: all not done
#DONE: cmpw ax, #imm16
#	   cmpw ax, rp
#		cmpw ax, hl+adr8
:CMPW AX,"#"imm16 	is op1b_byte=0x44; imm16 & AX{
	cmpw_set_flags(AX, imm16);
}

:CMPW AX,op1b_2xreg is op1b_hi=0x4 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & AX
{
	cmpw_set_flags(AX, op1b_2xreg);
}

:CMPW AX,[HL+adr8] 	is op1b_byte=0x61; op2b_byte=0x49; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, HL, adr8);
	local tmp = *:2 ptr;
	cmpw_set_flags(AX, tmp);
}

:CMPW AX,!addr16_2x is op1b_byte=0x42; addr16_2x & AX
{
	cmpw_set_flags(AX, addr16_2x);
}

#TODO: figure out how to make this less nasty without confusing the compiler:
:MULU X (AX"="A"*X")			is op1b_byte=0xD6 & X & A & AX
{
	local Aext:2 = zext(A:1);
	local Xext:2 = zext(X:1);
	AX = Aext * Xext;
}

#:MULHU
#:MULH
#:DIVHU
#:DIVWU
#:MACHU
#:MACH

#:INC
#TODO: set CY and AC flags
#TODO: all of inc except register direct mode
#				  		 inc [hl+byte]
#TODO: actually set flags


:INC op1b_reg0 		is op1b_hi=0x8 & op1b_b3=0 & op1b_reg0 {
	$(Z_flag) = (op1b_reg0 == 0xFF);
	op1b_reg0 = op1b_reg0 + 1;
}

:INC hl_offset 		is op1b_byte=0x61; op2b_byte=0x59; hl_offset
{
	$(Z_flag) = (hl_offset == 0xFF);
	hl_offset = hl_offset + 1;
}

#:DEC
#TODO: set CY and AC flags
#TODO: all of DEC except register mode
#						dec hl+byte
macro inst_dec(dst){
	$(Z_flag) = (dst == 0x1);
	dst = dst - 1;
}

:DEC op1b_reg0 		is op1b_hi=0x9 & op1b_b3=0 & op1b_reg0 {
	inst_dec(op1b_reg0);
}

:DEC hl_offset 		is op1b_byte=0x61; op2b_byte=0x69; hl_offset
{
	inst_dec(hl_offset);
}

#:INCW
#TODO: set CY and AC flags
#TODO: implemented thus far:
#				incw rp
#				incw hl+byte
macro inst_incw(dst){
	$(Z_flag) = (dst == 0xFFFF);
	dst = dst + 1;
}

:INCW op1b_2xreg 	is op1b_hi=0xA & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	inst_incw(op1b_2xreg);
}

:INCW hl_offset_word 	is op1b_byte=0x61; op2b_byte=0x79; hl_offset_word
{
	inst_incw(hl_offset_word);
}

#:DECW
#TODO: set CY and AC flags
#TODO: implemented thus far:
#				decw rp
#				decw [HL+adr8]
:DECW op1b_2xreg 	is op1b_hi=0xB & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	$(Z_flag) = (op1b_2xreg == 0x0001);
	op1b_2xreg = op1b_2xreg-1;
}

:DECW [HL+adr8] 	is op1b_byte=0x61; op2b_byte=0x89; adr8 & HL
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, HL, adr8);
	local tmp = *:2 ptr;
	*:2 ptr = tmp - 1;
}

#TODO: create right-shift macro
:SHR A, op2b_bit_sel is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xA & A
{
	local lobit:1 = 0;
	local shiftcount:1 = 0;
	local shifted:1 = A;
	<looptop>
	lobit = shifted[0,1];
	shiftcount = shiftcount + 1;
	shifted = shifted >> 1;
	if (shiftcount != op2b_bit_sel) goto <looptop>;
	$(CY_flag) = lobit&0x1;
	A = shifted;
}

:SHRW AX,op2b_hi_val	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xE & op2b_hi!=0x0 & AX {
	#TODO: just realized i screwed up how flags are set in shift ops, need to fix that.
	sr_set_flags16(AX, op2b_hi_val);
	AX = AX >> op2b_hi_val;
}

#:SHL
macro inst_shlw(reg, shiftamt){
	local hibt:1=0;
	local shiftcount:1 = 0;
	local shifted:2 = reg;
	<looptop>
	hibit = shifted[15,1];
	shiftcount = shiftcount+1;
	shifted = shifted<<1;
	if (shiftcount!=shiftamt) goto <looptop>;
	$(CY_flag)= hibit[0,1];
	reg = shifted;
}

:SHLW AX,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xD & op2b_hi!=0 & AX 
{
	inst_shlw(AX, op2b_hi_val);
}

:SHLW BC,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xC & op2b_hi!=0 & BC
{
	inst_shlw(BC, op2b_hi_val);
}

:SAR A,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xB & op2b_hi<0x8 & A {
	sr_set_flags8(A, op2b_hi_val);
	A = A s>> op2b_hi_val;
} 

macro inst_sarw(reg, shiftamt){
	local lobit:1=0;
	local shiftcount:1 = 0;
	local shifted:2 = reg;
	<looptop>
	lobit = shifted[15,1];
	shiftcount = shiftcount+1;
	shifted = shifted s>> 1;
	if (shiftcount!=shiftamt) goto <looptop>;
	$(CY_flag)= lobit[0,1];
	reg = shifted;
}

:SARW AX,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xF & op2b_hi!=0 & AX
{
	inst_sarw(AX, op2b_hi_val);
}

#:ROR
#:ROL
#:RORC
#:ROLC
#:ROLWC

#:MOV1
#TODO: 	all mov1 except mov1 CY, A.x
#						mov1 sfr.x, CY
#						mov1 CY, [HL].x
#						mov1 [HL].x, CY
#						MOV1 CY, saddr.x
#						MOV1 saddr.x, CY
:MOV1 op3b_sfr"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=0x0 & op2b_bit_sel & op2b_lo=0x9; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	local tmp = op3b_sfr;
	local mask = (0xFF & (~(0x1)<<op2b_bit_sel));
	tmp = tmp & mask;
	op3b_sfr = tmp|($(CY_flag)<<op2b_bit_sel);
}

:MOV1 "CY,"A"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xC & A
{
	$(CY_flag) = ((A>>op2b_bit_sel)&0x1);
}

#TODO: Ghidra thinks the bit select value is the offset. needs to be fixed.
:MOV1 "CY,"[HL]"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4 & HL 
{
	local tmp:1 = 0x0;
	read_byte(tmp, HL);
	$(CY_flag) = ((tmp>>op2b_bit_sel)&0x1);
}

:MOV1 [HL]"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x1 & HL
{
	local hl_dupe:1 = 0x0;
	read_byte(hl_dupe, HL);
	local mask = ~(0x1 << op2b_bit_sel);
	hl_dupe = hl_dupe & mask;
	hl_dupe = hl_dupe|($(CY_flag)<<op2b_bit_sel);
	write_byte(hl_dupe, HL);
}

:MOV1 "CY,"saddr"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x4; saddr
{
	local tmp:1 = 0x0;
	bit_get(saddr, op2b_bit_sel, tmp);
	$(CY_flag) = tmp[0,1];

}

:MOV1 saddr"."op2b_bit_sel",CY" 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x1; saddr 
{
	local tmp:1 = 0x0;
	bit_get(saddr, op2b_bit_sel, tmp);
	$(CY_flag) = tmp[0,1];
}
#:AND1
#:OR1
#:XOR1

#:SET1
#TODO: all set1 not in done list
#TODO: reuse bit_set_to macro in other spots
#Done: 				set1 !addr16.x
#					set1, sfr
#					set1 saddr

:SET1 !addr16_1x"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0; addr16_1x
{
	local tmp:1 = addr16_1x;
	bit_set_to(tmp, op2b_bit_sel, 1);
	addr16_1x = tmp;
}

:SET1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xA; sfr_raw1
{
	local tmp:1 = sfr_raw1;
	bit_set_to(tmp, op2b_bit_sel, 1);
	sfr_raw1 = tmp;
}

:SET1 saddr"."op2b_bit_sel 			is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x2; saddr
{
	local tmp:1 = saddr;
	bit_set_to(tmp, op2b_bit_sel, 1);
	saddr = tmp;
}
#:CLR1
#TODO: etc
#DONE: CLR1 addr16
#		CLR1 psw
#		CLR1 sfr
#		CLR! saddr
:CLR1 !addr16_1x"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=8; addr16_1x
{
	local tmp:1 = addr16_1x;
	bit_set_to(tmp, op2b_bit_sel, 0);
	addr16_1x = tmp;
}

:CLR1 op3b_sfr"."op2b_bit_sel 			is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xB; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	bit_set_to(op3b_sfr, op2b_bit_sel, 0);
}

:CLR1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xB; sfr_raw1 & uadr8<0xF0
{
	bit_set_to(sfr_raw1, op2b_bit_sel, 0);
}

:CLR1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x3; sfr_raw1
{
	local tmp:1 = sfr_raw1;
	bit_set_to(tmp, op2b_bit_sel, 0);
	sfr_raw1 = tmp;
}

#:CALL 
#TODO: all calls except addr16 type
#						addr20 type
macro inst_call(targ_func){
	local retpc:3 = inst_next;
	pushpc(retpc, 0x00:1);
	PC = &targ_func;
	call targ_func;
}

:CALL !jaddr16 		is op1b_byte=0xFD; jaddr16 
{
	inst_call(jaddr16);
}

:CALL !!jaddr20 	is op1b_byte=0xFC; jaddr20
{
	inst_call(jaddr20);
}


:CALLT callt_addr is op1b_byte=0x61; callt_addr
{
	inst_call(callt_addr);
}

#:BRK

:RET 				is op1b_byte=0xD7 
{
	local tmp:1 = 0;
	poppc(PC, tmp);
	return [PC];
}

:RETI 				is op1b_byte=0x61; op2b_byte=0xFC
{
	poppc(PC, PSW);
	return [PC];
}

#:RETB

#:PUSH
#TODO: need PUSH PSW
#TODO: resolve 1-byte store ops
:PUSH op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=1 {
	push(op1b_2xreg);
}

#:POP
#TODO: need POP PSW
#TODO: resolve 1-byte read ops
:POP op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=0 {
	pop(op1b_2xreg);
}

#:MOVW
#:ADDW
#:SUBW

#:BR
#TODO: All of BR except indirect address
#						BR !addr16
:BR "$"RelAddr8 		is op1b_byte=0xEF; RelAddr8 {
	goto RelAddr8;
}

:BR !jaddr16			is op1b_byte=0xED; jaddr16
{
	goto jaddr16;
}


:BC "$"RelAddr8			is op1b_byte=0xDC; RelAddr8 {
	if ($(CY_flag)) goto RelAddr8;
}

:BNC "$"RelAddr8 		is op1b_byte=0xDE; RelAddr8 {
	if (!$(CY_flag)) goto RelAddr8;
}

:BZ "$"RelAddr8 		is op1b_byte=0xDD; RelAddr8 {
	if ($(Z_flag)) goto RelAddr8;
}

:BNZ "$"RelAddr8 		is op1b_byte=0xDF; RelAddr8 {
	if (!$(Z_flag)) goto RelAddr8;
}

:BH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xC3; RelAddr8 {
	if (!($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

:BNH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xD3; RelAddr8 {
	if (($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

#:BT
#TODO: all
#DONE: BT A.x, adr8
#	   BT saddr.x, $addr20
#	   BT sfr.x, $addr20
macro inst_bt(src, bit_sel, jmpaddr){
	local bit = 0x0;
	bit_get(src, bit_sel, bit);
	if bit goto jmpaddr;
}

:BT A"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x3; RelAddr8 & A
{
	inst_bt(A, op2b_bit_sel, RelAddr8);
}

:BT saddr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x2; saddr; RelAddr8
{
	inst_bt(saddr, op2b_bit_sel, RelAddr8);
}

:BT sfr_raw1"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x2; sfr_raw1 & uadr8<0xF8; RelAddr8
{
	inst_bt(sfr_raw1, op2b_bit_sel, RelAddr8);
}

:BT op3b_sfr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x2; op3b_hi=0xF & op3b_b3=1 & op3b_sfr; RelAddr8
{
	inst_bt(op3b_sfr, op2b_bit_sel, RelAddr8);
}

#:BF
#TODO: all
#DONE: BF A.x, adr8
# 		BF saddr.x, $addr20
#		BF sfr.x, $addr20
macro inst_bf(src, bit_sel, jmpaddr){
	local bit = 0x0;
	bit_get(src, bit_sel, bit);
	if !bit goto jmpaddr;
}

:BF A"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x5; RelAddr8 & A
{
	inst_bf(A, op2b_bit_sel, RelAddr8);
}

:BF saddr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x4; saddr; RelAddr8
{
	inst_bf(saddr, op2b_bit_sel, RelAddr8);
}

:BF op3b_sfr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4; op3b_hi=0xF & op3b_b3=1 & op3b_sfr; RelAddr8
{
	inst_bf(op3b_sfr, op2b_bit_sel, RelAddr8);
}

:BF sfr_raw1"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4; sfr_raw1 & uadr8<0xF8; RelAddr8
{
	inst_bf(sfr_raw1, op2b_bit_sel, RelAddr8);
}



#:BTCLR

:SKC 					is op1b_byte=0x61; op2b_byte=0xC8
{
	if $(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNC					is op1b_byte=0x61; op2b_byte=0xD8
{
	if !$(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKZ 					is op1b_byte=0x61; op2b_byte=0xE8 
{
	if  $(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNZ 					is op1b_byte=0x61; op2b_byte=0xF8 
{
	if !$(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

#:SKH
#:SKNH

:SEL "RB"op2b_reg_rbsel			is op1b_byte=0x61; op2b_hi2=0x3 & op2b_reg_rbsel & op2b_lo=0xF
{
	$(RBS1_flag) = ((op2b_reg_rbsel>>1)&0x1);
	$(RBS0_flag) = op2b_reg_rbsel&0x1;
}

:NOP					is op1b_byte=0x00 {}

#:EI
#:DI
#:HALT
#:STOP
#:PREFIX
