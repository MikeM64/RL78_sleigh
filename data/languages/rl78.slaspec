#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg
#
# MikeM64, 2020
#########################################################################

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 wordsize=1 default;
define space stackarea  type=ram_space      size=2;
define space register   type=register_space size=1;

# General Purpose registers
define register offset=0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit-mode bank3
define register offset=0x00 size=2 [AX3   BC3   DE3   HL3  ];  #16-bit-mode bank3
define register offset=0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit-mode bank2
define register offset=0x08 size=2 [AX2   BC2   DE2   HL2  ];  #16-bit-mode bank2
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit-mode bank1
define register offset=0x10 size=2 [AX1   BC1   DE1   HL1  ];  #16-bit-mode bank1
define register offset=0x18 size=1 [X  A  C  B  E  D  L  H ];  # 8-bit-mode bank0
define register offset=0x18 size=2 [AX    BC    DE    HL   ];  #16-bit-mode bank0

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x60 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z RBS1 AC RBS0 ISP1 ISP0 CY];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    byte1 = (0, 7)
    op = (4, 7)
    dreg_byte = (0, 2)
    sreg_byte = (0, 2);
attach variables [ dreg_byte sreg_byte ] [X A C B E D L H];

define token base2 (8)
    byte2 = (0, 7)
    data2 = (0, 7);

#########################################################################
#
# Instruction macros
#
#########################################################################

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

#########################################################################
#
# Root table instructions
#
#########################################################################

:NOP is byte1=0x00 {}

:HALT is byte1=0x61; byte2=0xED { halt(); }

:STOP is byte1=0x61; byte2=0xFD { stop(); }

# MOV r, #byte
:MOV dreg_byte, "#"data2 is op=0x5 & dreg_byte; data2 {
    dreg_byte = data2;
}

# MOV A, r
:MOV A, sreg_byte is op=0x6 & A & sreg_byte {
    A = sreg_byte;
}

# INC r
:INC dreg_byte is op=0x8 & dreg_byte {
    inst_inc(dreg_byte);
}

# DEC r
:DEC dreg_byte is op=0x9 & dreg_byte {
    inst_dec(dreg_byte);
}
