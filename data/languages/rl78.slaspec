##########################################################################
#
# Attempt at implementing the RL78
# 16-bit MCU ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

define endian=little;
define alignment=1;

define space ram 		type=ram_space		size=2 	default;
define space register 	type=register_space size=1;

@define PTRSIZE "2"

#general purpose registers:
define register offset= 0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3]; 	# 8-bit-mode bank3
define register offset= 0x00 size=2 [AX3   CB3   DE3   HL3];	#16-bit-mode bank3
define register offset= 0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2]; 	# 8-bit-mode bank2
define register offset= 0x08 size=2 [AX2   CB2   DE2   HL2];	#16-bit-mode bank2
define register offset= 0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1]; 	# 8-bit-mode bank1
define register offset= 0x10 size=2 [AX1   CB1   DE1   HL1];	#16-bit-mode bank1
define register offset= 0x18 size=1 [X  A  C  B  E  D  L  H]; 	# 8-bit-mode bank0
define register offset= 0x18 size=2 [AX    CB    DE    HL];	 	#16-bit-mode bank0

#special purpose registers
define register offset=0x40 size=4 [PC]; #I Think this is right??? they don't specify
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];

#Flag bits
#Macros? I think? to make accessing the bits in the PSW easier
@define IE_flag 	"PSW[7,1]"	# Interrupt Enable (IE)
@define Z_flag  	"PSW[6,1]" 	# Zero Flag (Z)
@define RBS1_flag   "PSW[5,1]"	# Register Bank Select Hi-Bit (RBS1)
@define AC_flag 	"PSW[4,1]"  # Auxiliary Carry Flag (AC)
@define RBS0_flag	"PSW[3,1]" 	# Register Bank Select Lo-Bit (RBS0)
@define ISP1_flag 	"PSW[2,1]" 	# In-service priority flag Hi-Bit (ISP1)
@define ISP0_flag 	"PSW[1,1]"  # In-service priority flag Lo-Bit (ISP0)
@define CY_flag 	"PSW[0,1]"  # Carry flag (CY)


#########################################################################
#
# Operand data types
#
#########################################################################

define token op1b (8) 
	op1b_byte = (0,7)
	op1b_hi = (4,7)
	op1b_lo = (0,3)
	op1b_lo3 = (0,2)
	op1b_reg0 = (0,2)
	op1b_2xreg = (1,2)
	op1b_b3 = (3,3)
	op1b_b2 = (2,2)
	op1b_b1 = (1,1)
	op1b_b0 = (0,0)
;

define token op2b (8)
	op2b_byte = (0,7)
	op2b_hi = (4,7)
	op2b_hi_val = (4,7)
	op2b_lo = (0,3)
;

define token op3b (8)	
	op3b_byte0 = (0,7)
;

define token data8 (8)
	imm8 = (0,7)
	simm8 = (0,7) signed
;

define token data16 (16)
	imm16 = (0,15)
	imm16_lo = (0,7)
	imm16_hi = (8,15)
	simm16 = (0,15) signed
;

attach variables [op1b_reg0] 	[X A C B E D L H];
attach variables [op1b_2xreg]	[AX CB DE HL];

##########################################################################
#
# Macros
#
##########################################################################

#macro push16(val16) {
#	SP = SP - 2;
#	ptr:$(PTRSIZE) = SP;
#	*:2 ptr = val16; 
#}

macro addw_set_flags(val1, val2){
	local tmp1:2;
	local tmp2:2;
	tmp1 = (val1>>15)&0x1;
	tmp2 = (val2>>15)&0x1;
	$(CY_flag) = tmp1[0,1] & tmp2[0,1];
	$(Z_flag) = (val1 == (-val2));
	$(AC_flag) = 0;
}

RelAddr8: loc  is simm8  [ loc = inst_next + simm8; ]        { export *:1 loc; }

#Imm16Swap: val is imm16_lo; imm16_hi [val=val|imm16_hi; val=val<<8; val=val|imm16_lo;] {export val;}

##########################################################################
#
# Instructions
#
##########################################################################
#MOV
:MOV op1b_reg0," #"imm8	is op1b_hi=0x5 & op1b_b3!=0x1 & op1b_reg0; imm8 {
	op1b_reg0 = imm8;
}

#TODO: CD, CE, and CF moves

:MOV "A",op1b_reg0 		is op1b_hi=0x6 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 {
	A = op1b_reg0;
}

:MOV op1b_reg0,"A"		is op1b_hi=0x7 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 {
	op1b_reg0 = A;
}

#TODO: The rest of MOV

#:XCH
#:ONEB
#:CLRB
#:MOVS

#:MOVW
#TODO: The rest of MOVW
:MOVW op1b_2xreg," #"imm16 	is op1b_hi=0x3 & op1b_b3!=0x1 & op1b_2xreg & op1b_b0!=0x1; imm16{
	op1b_2xreg = imm16;
}

#:XCHW
#:ONEW
#:CLRW
#:ADD
#:ADDC
#:SUB
#:SUBC
#:AND
#:OR
#:XOR

#:CMP
#TODO: All but case 1 of CMP
:CMP "A","#"imm8 	is op1b_byte=0x4C; imm8 {
	$(Z_flag) = ((imm8 - A) == 0);
	$(CY_flag) = ((imm8 & 0x7f) < (A & 0x7f));
	$(AC_flag) = ((imm8 & 0x07) < (A & 0x07));
}

#:CMP0
#:CMPS

#:ADDW
#TODO: ADDW SP 
:ADDW "AX","#"simm16 	is op1b_byte=0x04; simm16 {
	addw_set_flags(AX, simm16);
	AX = AX + simm16;
}

#:SUBW
#:CMPW
#:MULU
#:MULHU
#:MULH
#:DIVHU
#:DIVWU
#:MACHU
#:MACH
#:INC
#:DEC
#:INCW
#:DECW
#:SHR

:SHRW "AX",op2b_hi_val	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xE & op2b_hi!=0x0 {
	local mask:2 = (0x1:2 << op2b_hi_val);
	local tmp:2 = ((mask & AX) >> op2b_hi_val) & 0x1:2;
	local tmp2:1 = tmp[0,7];
	$(CY_flag) = tmp2;
	AX = AX >> op2b_hi_val;
}

#:SHL
#:SHLW
#:SAR
#:SARW
#:ROR
#:ROL
#:RORC
#:ROLC
#:ROLWC
#:MOV1
#:AND1
#:OR1
#:XOR1
#:SET1
#:CLR1
#:CALL
#:CALLT
#:BRK
#:RET
#:RETI
#:RETB

#:PUSH
#TODO: need PUSH PSW
#TODO: resolve 1-byte store ops
:PUSH op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=1 {
	SP = SP - 2;
	*:2 SP = op1b_2xreg;
}

#:POP
#:MOVW
#:ADDW
#:SUBW
#:BR

:BC "$"RelAddr8			is op1b_byte=0xDC; RelAddr8 {
	if ($(CY_flag)) goto RelAddr8;
}

:BNC "$"RelAddr8 		is op1b_byte=0xDE; RelAddr8 {
	if (!$(CY_flag)) goto RelAddr8;
}

:BZ "$"RelAddr8 		is op1b_byte=0xDD; RelAddr8 {
	if ($(Z_flag)) goto RelAddr8;
}

:BNZ "$"RelAddr8 		is op1b_byte=0xDF; RelAddr8 {
	if (!$(Z_flag)) goto RelAddr8;
}

:BH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xC3; RelAddr8 {
	if (!($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

:BNH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xD3; RelAddr8 {
	if (($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

#:BT
#:BF
#:BTCLR
#:SKC
#:SKNC
#:SKZ
#:SKNZ
#:SKH
#:SKNH
#:SEL

:NOP					is op1b_byte=0x00 {}

#:EI
#:DI
#:HALT
#:STOP
#:PREFIX
